/*!
 * sdk.client v1.0.0
 * (c) 2014-2023 .
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/awaitqueue/lib/Logger.js":
/*!***********************************************!*\
  !*** ./node_modules/awaitqueue/lib/Logger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Logger = void 0;
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
var LIB_NAME = 'awaitqueue';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    if (prefix) {
      this._debug = (0, debug_1["default"])("".concat(LIB_NAME, ":").concat(prefix));
      this._warn = (0, debug_1["default"])("".concat(LIB_NAME, ":WARN:").concat(prefix));
      this._error = (0, debug_1["default"])("".concat(LIB_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = (0, debug_1["default"])(LIB_NAME);
      this._warn = (0, debug_1["default"])("".concat(LIB_NAME, ":WARN"));
      this._error = (0, debug_1["default"])("".concat(LIB_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
  return Logger;
}();
exports.Logger = Logger;

/***/ }),

/***/ "./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/awaitqueue/lib/Logger.js");
var logger = new Logger_1.Logger();
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */
var AwaitQueueStoppedError = /*#__PURE__*/function (_Error) {
  _inherits(AwaitQueueStoppedError, _Error);
  var _super = _createSuper(AwaitQueueStoppedError);
  function AwaitQueueStoppedError(message) {
    var _this;
    _classCallCheck(this, AwaitQueueStoppedError);
    _this = _super.call(this, message !== null && message !== void 0 ? message : 'AwaitQueue stopped');
    _this.name = 'AwaitQueueStoppedError';
    // @ts-ignore
    if (typeof Error.captureStackTrace === 'function') {
      // @ts-ignore
      Error.captureStackTrace(_assertThisInitialized(_this), AwaitQueueStoppedError);
    }
    return _this;
  }
  return _createClass(AwaitQueueStoppedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */
var AwaitQueueRemovedTaskError = /*#__PURE__*/function (_Error2) {
  _inherits(AwaitQueueRemovedTaskError, _Error2);
  var _super2 = _createSuper(AwaitQueueRemovedTaskError);
  function AwaitQueueRemovedTaskError(message) {
    var _this2;
    _classCallCheck(this, AwaitQueueRemovedTaskError);
    _this2 = _super2.call(this, message !== null && message !== void 0 ? message : 'AwaitQueue task removed');
    _this2.name = 'AwaitQueueRemovedTaskError';
    // @ts-ignore
    if (typeof Error.captureStackTrace === 'function') {
      // @ts-ignore
      Error.captureStackTrace(_assertThisInitialized(_this2), AwaitQueueRemovedTaskError);
    }
    return _this2;
  }
  return _createClass(AwaitQueueRemovedTaskError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
var AwaitQueue = /*#__PURE__*/function () {
  function AwaitQueue() {
    _classCallCheck(this, AwaitQueue);
    // Queue of pending tasks (map of PendingTasks indexed by id).
    this.pendingTasks = new Map();
    // Incrementing PendingTask id.
    this.nextTaskId = 0;
    // Whether stop() method is stopping all pending tasks.
    this.stopping = false;
  }
  _createClass(AwaitQueue, [{
    key: "size",
    get: function get() {
      return this.pendingTasks.size;
    }
  }, {
    key: "push",
    value: function () {
      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(task, name) {
        var _name,
          _this3 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              name = (_name = name) !== null && _name !== void 0 ? _name : task.name;
              logger.debug("push() [name:".concat(name, "]"));
              if (!(typeof task !== 'function')) {
                _context.next = 4;
                break;
              }
              throw new TypeError('given task is not a function');
            case 4:
              if (name) {
                try {
                  Object.defineProperty(task, 'name', {
                    value: name
                  });
                } catch (error) {}
              }
              return _context.abrupt("return", new Promise(function (_resolve, _reject) {
                var pendingTask = {
                  id: _this3.nextTaskId++,
                  task: task,
                  name: name,
                  enqueuedAt: Date.now(),
                  executedAt: undefined,
                  completed: false,
                  resolve: function resolve(result) {
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) {
                      return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    _this3.pendingTasks["delete"](pendingTask.id);
                    logger.debug("resolving task [name:".concat(pendingTask.name, "]"));
                    // Resolve the task with the obtained result.
                    _resolve(result);
                    // Execute the next pending task (if any).
                    var _this3$pendingTasks$v = _this3.pendingTasks.values(),
                      _this3$pendingTasks$v2 = _slicedToArray(_this3$pendingTasks$v, 1),
                      nextPendingTask = _this3$pendingTasks$v2[0];
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                      void _this3.execute(nextPendingTask);
                    }
                  },
                  reject: function reject(error) {
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) {
                      return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    _this3.pendingTasks["delete"](pendingTask.id);
                    logger.debug("rejecting task [name:".concat(pendingTask.name, "]: %s"), String(error));
                    // Reject the task with the obtained error.
                    _reject(error);
                    // Execute the next pending task (if any) unless stop() is running.
                    if (!_this3.stopping) {
                      var _this3$pendingTasks$v3 = _this3.pendingTasks.values(),
                        _this3$pendingTasks$v4 = _slicedToArray(_this3$pendingTasks$v3, 1),
                        nextPendingTask = _this3$pendingTasks$v4[0];
                      // NOTE: During the reject() callback the user app may have interacted
                      // with the queue. For instance, the app may have pushed a task while
                      // the queue was empty so such a task is already being executed. If so,
                      // don't execute it twice.
                      if (nextPendingTask && !nextPendingTask.executedAt) {
                        void _this3.execute(nextPendingTask);
                      }
                    }
                  }
                };
                // Append task to the queue.
                _this3.pendingTasks.set(pendingTask.id, pendingTask);
                // And execute it if this is the only task in the queue.
                if (_this3.pendingTasks.size === 1) {
                  void _this3.execute(pendingTask);
                }
              }));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function push(_x, _x2) {
        return _push.apply(this, arguments);
      }
      return push;
    }()
  }, {
    key: "stop",
    value: function stop() {
      logger.debug('stop()');
      this.stopping = true;
      var _iterator = _createForOfIteratorHelper(this.pendingTasks.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pendingTask = _step.value;
          logger.debug("stop() | stopping task [name:".concat(pendingTask.name, "]"));
          pendingTask.reject(new AwaitQueueStoppedError());
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this.stopping = false;
    }
  }, {
    key: "remove",
    value: function remove(taskIdx) {
      logger.debug("remove() [taskIdx:".concat(taskIdx, "]"));
      var pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
      if (!pendingTask) {
        logger.debug("stop() | no task with given idx [taskIdx:".concat(taskIdx, "]"));
        return;
      }
      pendingTask.reject(new AwaitQueueRemovedTaskError());
    }
  }, {
    key: "dump",
    value: function dump() {
      var now = Date.now();
      var idx = 0;
      return Array.from(this.pendingTasks.values()).map(function (pendingTask) {
        return {
          idx: idx++,
          task: pendingTask.task,
          name: pendingTask.name,
          enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
          executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
        };
      });
    }
  }, {
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(pendingTask) {
        var result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug("execute() [name:".concat(pendingTask.name, "]"));
              if (!pendingTask.executedAt) {
                _context2.next = 3;
                break;
              }
              throw new Error('task already being executed');
            case 3:
              pendingTask.executedAt = Date.now();
              _context2.prev = 4;
              _context2.next = 7;
              return pendingTask.task();
            case 7:
              result = _context2.sent;
              // Resolve the task with its resolved result (if any).
              pendingTask.resolve(result);
              _context2.next = 14;
              break;
            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](4);
              // Reject the task with its rejected error.
              pendingTask.reject(_context2.t0);
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[4, 11]]);
      }));
      function execute(_x3) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
  }]);
  return AwaitQueue;
}();
exports.AwaitQueue = AwaitQueue;

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
!function (e, t) {
  "object" == ( false ? 0 : _typeof(exports)) && "object" == ( false ? 0 : _typeof(module)) ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
}(this, function () {
  return function (e) {
    var t = {};
    function r(n) {
      if (t[n]) return t[n].exports;
      var i = t[n] = {
        i: n,
        l: !1,
        exports: {}
      };
      return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;
    }
    return r.m = e, r.c = t, r.d = function (e, t, n) {
      r.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: n
      });
    }, r.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, r.t = function (e, t) {
      if (1 & t && (e = r(e)), 8 & t) return e;
      if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;
      var n = Object.create(null);
      if (r.r(n), Object.defineProperty(n, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e) for (var i in e) r.d(n, i, function (t) {
        return e[t];
      }.bind(null, i));
      return n;
    }, r.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e["default"];
      } : function () {
        return e;
      };
      return r.d(t, "a", t), t;
    }, r.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, r.p = "", r(r.s = 90);
  }({
    17: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n = r(18),
        i = function () {
          function e() {}
          return e.getFirstMatch = function (e, t) {
            var r = t.match(e);
            return r && r.length > 0 && r[1] || "";
          }, e.getSecondMatch = function (e, t) {
            var r = t.match(e);
            return r && r.length > 1 && r[2] || "";
          }, e.matchAndReturnConst = function (e, t, r) {
            if (e.test(t)) return r;
          }, e.getWindowsVersionName = function (e) {
            switch (e) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return;
            }
          }, e.getMacOSVersionName = function (e) {
            var t = e.split(".").splice(0, 2).map(function (e) {
              return parseInt(e, 10) || 0;
            });
            if (t.push(0), 10 === t[0]) switch (t[1]) {
              case 5:
                return "Leopard";
              case 6:
                return "Snow Leopard";
              case 7:
                return "Lion";
              case 8:
                return "Mountain Lion";
              case 9:
                return "Mavericks";
              case 10:
                return "Yosemite";
              case 11:
                return "El Capitan";
              case 12:
                return "Sierra";
              case 13:
                return "High Sierra";
              case 14:
                return "Mojave";
              case 15:
                return "Catalina";
              default:
                return;
            }
          }, e.getAndroidVersionName = function (e) {
            var t = e.split(".").splice(0, 2).map(function (e) {
              return parseInt(e, 10) || 0;
            });
            if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0;
          }, e.getVersionPrecision = function (e) {
            return e.split(".").length;
          }, e.compareVersions = function (t, r, n) {
            void 0 === n && (n = !1);
            var i = e.getVersionPrecision(t),
              s = e.getVersionPrecision(r),
              a = Math.max(i, s),
              o = 0,
              u = e.map([t, r], function (t) {
                var r = a - e.getVersionPrecision(t),
                  n = t + new Array(r + 1).join(".0");
                return e.map(n.split("."), function (e) {
                  return new Array(20 - e.length).join("0") + e;
                }).reverse();
              });
            for (n && (o = a - Math.min(i, s)), a -= 1; a >= o;) {
              if (u[0][a] > u[1][a]) return 1;
              if (u[0][a] === u[1][a]) {
                if (a === o) return 0;
                a -= 1;
              } else if (u[0][a] < u[1][a]) return -1;
            }
          }, e.map = function (e, t) {
            var r,
              n = [];
            if (Array.prototype.map) return Array.prototype.map.call(e, t);
            for (r = 0; r < e.length; r += 1) n.push(t(e[r]));
            return n;
          }, e.find = function (e, t) {
            var r, n;
            if (Array.prototype.find) return Array.prototype.find.call(e, t);
            for (r = 0, n = e.length; r < n; r += 1) {
              var i = e[r];
              if (t(i, r)) return i;
            }
          }, e.assign = function (e) {
            for (var t, r, n = e, i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) s[a - 1] = arguments[a];
            if (Object.assign) return Object.assign.apply(Object, [e].concat(s));
            var o = function o() {
              var e = s[t];
              "object" == _typeof(e) && null !== e && Object.keys(e).forEach(function (t) {
                n[t] = e[t];
              });
            };
            for (t = 0, r = s.length; t < r; t += 1) o();
            return e;
          }, e.getBrowserAlias = function (e) {
            return n.BROWSER_ALIASES_MAP[e];
          }, e.getBrowserTypeByAlias = function (e) {
            return n.BROWSER_MAP[e] || "";
          }, e;
        }();
      t["default"] = i, e.exports = t["default"];
    },
    18: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
      t.BROWSER_ALIASES_MAP = {
        "Amazon Silk": "amazon_silk",
        "Android Browser": "android",
        Bada: "bada",
        BlackBerry: "blackberry",
        Chrome: "chrome",
        Chromium: "chromium",
        Electron: "electron",
        Epiphany: "epiphany",
        Firefox: "firefox",
        Focus: "focus",
        Generic: "generic",
        "Google Search": "google_search",
        Googlebot: "googlebot",
        "Internet Explorer": "ie",
        "K-Meleon": "k_meleon",
        Maxthon: "maxthon",
        "Microsoft Edge": "edge",
        "MZ Browser": "mz",
        "NAVER Whale Browser": "naver",
        Opera: "opera",
        "Opera Coast": "opera_coast",
        PhantomJS: "phantomjs",
        Puffin: "puffin",
        QupZilla: "qupzilla",
        QQ: "qq",
        QQLite: "qqlite",
        Safari: "safari",
        Sailfish: "sailfish",
        "Samsung Internet for Android": "samsung_internet",
        SeaMonkey: "seamonkey",
        Sleipnir: "sleipnir",
        Swing: "swing",
        Tizen: "tizen",
        "UC Browser": "uc",
        Vivaldi: "vivaldi",
        "WebOS Browser": "webos",
        WeChat: "wechat",
        "Yandex Browser": "yandex",
        Roku: "roku"
      };
      t.BROWSER_MAP = {
        amazon_silk: "Amazon Silk",
        android: "Android Browser",
        bada: "Bada",
        blackberry: "BlackBerry",
        chrome: "Chrome",
        chromium: "Chromium",
        electron: "Electron",
        epiphany: "Epiphany",
        firefox: "Firefox",
        focus: "Focus",
        generic: "Generic",
        googlebot: "Googlebot",
        google_search: "Google Search",
        ie: "Internet Explorer",
        k_meleon: "K-Meleon",
        maxthon: "Maxthon",
        edge: "Microsoft Edge",
        mz: "MZ Browser",
        naver: "NAVER Whale Browser",
        opera: "Opera",
        opera_coast: "Opera Coast",
        phantomjs: "PhantomJS",
        puffin: "Puffin",
        qupzilla: "QupZilla",
        qq: "QQ Browser",
        qqlite: "QQ Browser Lite",
        safari: "Safari",
        sailfish: "Sailfish",
        samsung_internet: "Samsung Internet for Android",
        seamonkey: "SeaMonkey",
        sleipnir: "Sleipnir",
        swing: "Swing",
        tizen: "Tizen",
        uc: "UC Browser",
        vivaldi: "Vivaldi",
        webos: "WebOS Browser",
        wechat: "WeChat",
        yandex: "Yandex Browser"
      };
      t.PLATFORMS_MAP = {
        tablet: "tablet",
        mobile: "mobile",
        desktop: "desktop",
        tv: "tv"
      };
      t.OS_MAP = {
        WindowsPhone: "Windows Phone",
        Windows: "Windows",
        MacOS: "macOS",
        iOS: "iOS",
        Android: "Android",
        WebOS: "WebOS",
        BlackBerry: "BlackBerry",
        Bada: "Bada",
        Tizen: "Tizen",
        Linux: "Linux",
        ChromeOS: "Chrome OS",
        PlayStation4: "PlayStation 4",
        Roku: "Roku"
      };
      t.ENGINE_MAP = {
        EdgeHTML: "EdgeHTML",
        Blink: "Blink",
        Trident: "Trident",
        Presto: "Presto",
        Gecko: "Gecko",
        WebKit: "WebKit"
      };
    },
    90: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n,
        i = (n = r(91)) && n.__esModule ? n : {
          "default": n
        },
        s = r(18);
      function a(e, t) {
        for (var r = 0; r < t.length; r++) {
          var n = t[r];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
      }
      var o = function () {
        function e() {}
        var t, r, n;
        return e.getParser = function (e, t) {
          if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
          return new i["default"](e, t);
        }, e.parse = function (e) {
          return new i["default"](e).getResult();
        }, t = e, n = [{
          key: "BROWSER_MAP",
          get: function get() {
            return s.BROWSER_MAP;
          }
        }, {
          key: "ENGINE_MAP",
          get: function get() {
            return s.ENGINE_MAP;
          }
        }, {
          key: "OS_MAP",
          get: function get() {
            return s.OS_MAP;
          }
        }, {
          key: "PLATFORMS_MAP",
          get: function get() {
            return s.PLATFORMS_MAP;
          }
        }], (r = null) && a(t.prototype, r), n && a(t, n), e;
      }();
      t["default"] = o, e.exports = t["default"];
    },
    91: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n = u(r(92)),
        i = u(r(93)),
        s = u(r(94)),
        a = u(r(95)),
        o = u(r(17));
      function u(e) {
        return e && e.__esModule ? e : {
          "default": e
        };
      }
      var d = function () {
        function e(e, t) {
          if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
          this._ua = e, this.parsedResult = {}, !0 !== t && this.parse();
        }
        var t = e.prototype;
        return t.getUA = function () {
          return this._ua;
        }, t.test = function (e) {
          return e.test(this._ua);
        }, t.parseBrowser = function () {
          var e = this;
          this.parsedResult.browser = {};
          var t = o["default"].find(n["default"], function (t) {
            if ("function" == typeof t.test) return t.test(e);
            if (t.test instanceof Array) return t.test.some(function (t) {
              return e.test(t);
            });
            throw new Error("Browser's test function is not valid");
          });
          return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
        }, t.getBrowser = function () {
          return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
        }, t.getBrowserName = function (e) {
          return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
        }, t.getBrowserVersion = function () {
          return this.getBrowser().version;
        }, t.getOS = function () {
          return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
        }, t.parseOS = function () {
          var e = this;
          this.parsedResult.os = {};
          var t = o["default"].find(i["default"], function (t) {
            if ("function" == typeof t.test) return t.test(e);
            if (t.test instanceof Array) return t.test.some(function (t) {
              return e.test(t);
            });
            throw new Error("Browser's test function is not valid");
          });
          return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
        }, t.getOSName = function (e) {
          var t = this.getOS().name;
          return e ? String(t).toLowerCase() || "" : t || "";
        }, t.getOSVersion = function () {
          return this.getOS().version;
        }, t.getPlatform = function () {
          return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
        }, t.getPlatformType = function (e) {
          void 0 === e && (e = !1);
          var t = this.getPlatform().type;
          return e ? String(t).toLowerCase() || "" : t || "";
        }, t.parsePlatform = function () {
          var e = this;
          this.parsedResult.platform = {};
          var t = o["default"].find(s["default"], function (t) {
            if ("function" == typeof t.test) return t.test(e);
            if (t.test instanceof Array) return t.test.some(function (t) {
              return e.test(t);
            });
            throw new Error("Browser's test function is not valid");
          });
          return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
        }, t.getEngine = function () {
          return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
        }, t.getEngineName = function (e) {
          return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
        }, t.parseEngine = function () {
          var e = this;
          this.parsedResult.engine = {};
          var t = o["default"].find(a["default"], function (t) {
            if ("function" == typeof t.test) return t.test(e);
            if (t.test instanceof Array) return t.test.some(function (t) {
              return e.test(t);
            });
            throw new Error("Browser's test function is not valid");
          });
          return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
        }, t.parse = function () {
          return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
        }, t.getResult = function () {
          return o["default"].assign({}, this.parsedResult);
        }, t.satisfies = function (e) {
          var t = this,
            r = {},
            n = 0,
            i = {},
            s = 0;
          if (Object.keys(e).forEach(function (t) {
            var a = e[t];
            "string" == typeof a ? (i[t] = a, s += 1) : "object" == _typeof(a) && (r[t] = a, n += 1);
          }), n > 0) {
            var a = Object.keys(r),
              u = o["default"].find(a, function (e) {
                return t.isOS(e);
              });
            if (u) {
              var d = this.satisfies(r[u]);
              if (void 0 !== d) return d;
            }
            var c = o["default"].find(a, function (e) {
              return t.isPlatform(e);
            });
            if (c) {
              var f = this.satisfies(r[c]);
              if (void 0 !== f) return f;
            }
          }
          if (s > 0) {
            var l = Object.keys(i),
              h = o["default"].find(l, function (e) {
                return t.isBrowser(e, !0);
              });
            if (void 0 !== h) return this.compareVersion(i[h]);
          }
        }, t.isBrowser = function (e, t) {
          void 0 === t && (t = !1);
          var r = this.getBrowserName().toLowerCase(),
            n = e.toLowerCase(),
            i = o["default"].getBrowserTypeByAlias(n);
          return t && i && (n = i.toLowerCase()), n === r;
        }, t.compareVersion = function (e) {
          var t = [0],
            r = e,
            n = !1,
            i = this.getBrowserVersion();
          if ("string" == typeof i) return ">" === e[0] || "<" === e[0] ? (r = e.substr(1), "=" === e[1] ? (n = !0, r = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? r = e.substr(1) : "~" === e[0] && (n = !0, r = e.substr(1)), t.indexOf(o["default"].compareVersions(i, r, n)) > -1;
        }, t.isOS = function (e) {
          return this.getOSName(!0) === String(e).toLowerCase();
        }, t.isPlatform = function (e) {
          return this.getPlatformType(!0) === String(e).toLowerCase();
        }, t.isEngine = function (e) {
          return this.getEngineName(!0) === String(e).toLowerCase();
        }, t.is = function (e, t) {
          return void 0 === t && (t = !1), this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e);
        }, t.some = function (e) {
          var t = this;
          return void 0 === e && (e = []), e.some(function (e) {
            return t.is(e);
          });
        }, e;
      }();
      t["default"] = d, e.exports = t["default"];
    },
    92: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n,
        i = (n = r(17)) && n.__esModule ? n : {
          "default": n
        };
      var s = /version\/(\d+(\.?_?\d+)+)/i,
        a = [{
          test: [/googlebot/i],
          describe: function describe(e) {
            var t = {
                name: "Googlebot"
              },
              r = i["default"].getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/opera/i],
          describe: function describe(e) {
            var t = {
                name: "Opera"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/opr\/|opios/i],
          describe: function describe(e) {
            var t = {
                name: "Opera"
              },
              r = i["default"].getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/SamsungBrowser/i],
          describe: function describe(e) {
            var t = {
                name: "Samsung Internet for Android"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/Whale/i],
          describe: function describe(e) {
            var t = {
                name: "NAVER Whale Browser"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/MZBrowser/i],
          describe: function describe(e) {
            var t = {
                name: "MZ Browser"
              },
              r = i["default"].getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/focus/i],
          describe: function describe(e) {
            var t = {
                name: "Focus"
              },
              r = i["default"].getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/swing/i],
          describe: function describe(e) {
            var t = {
                name: "Swing"
              },
              r = i["default"].getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/coast/i],
          describe: function describe(e) {
            var t = {
                name: "Opera Coast"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/opt\/\d+(?:.?_?\d+)+/i],
          describe: function describe(e) {
            var t = {
                name: "Opera Touch"
              },
              r = i["default"].getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/yabrowser/i],
          describe: function describe(e) {
            var t = {
                name: "Yandex Browser"
              },
              r = i["default"].getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/ucbrowser/i],
          describe: function describe(e) {
            var t = {
                name: "UC Browser"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/Maxthon|mxios/i],
          describe: function describe(e) {
            var t = {
                name: "Maxthon"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/epiphany/i],
          describe: function describe(e) {
            var t = {
                name: "Epiphany"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/puffin/i],
          describe: function describe(e) {
            var t = {
                name: "Puffin"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/sleipnir/i],
          describe: function describe(e) {
            var t = {
                name: "Sleipnir"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/k-meleon/i],
          describe: function describe(e) {
            var t = {
                name: "K-Meleon"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/micromessenger/i],
          describe: function describe(e) {
            var t = {
                name: "WeChat"
              },
              r = i["default"].getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/qqbrowser/i],
          describe: function describe(e) {
            var t = {
                name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
              },
              r = i["default"].getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/msie|trident/i],
          describe: function describe(e) {
            var t = {
                name: "Internet Explorer"
              },
              r = i["default"].getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/\sedg\//i],
          describe: function describe(e) {
            var t = {
                name: "Microsoft Edge"
              },
              r = i["default"].getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/edg([ea]|ios)/i],
          describe: function describe(e) {
            var t = {
                name: "Microsoft Edge"
              },
              r = i["default"].getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/vivaldi/i],
          describe: function describe(e) {
            var t = {
                name: "Vivaldi"
              },
              r = i["default"].getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/seamonkey/i],
          describe: function describe(e) {
            var t = {
                name: "SeaMonkey"
              },
              r = i["default"].getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/sailfish/i],
          describe: function describe(e) {
            var t = {
                name: "Sailfish"
              },
              r = i["default"].getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/silk/i],
          describe: function describe(e) {
            var t = {
                name: "Amazon Silk"
              },
              r = i["default"].getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/phantom/i],
          describe: function describe(e) {
            var t = {
                name: "PhantomJS"
              },
              r = i["default"].getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/slimerjs/i],
          describe: function describe(e) {
            var t = {
                name: "SlimerJS"
              },
              r = i["default"].getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
          describe: function describe(e) {
            var t = {
                name: "BlackBerry"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/(web|hpw)[o0]s/i],
          describe: function describe(e) {
            var t = {
                name: "WebOS Browser"
              },
              r = i["default"].getFirstMatch(s, e) || i["default"].getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/bada/i],
          describe: function describe(e) {
            var t = {
                name: "Bada"
              },
              r = i["default"].getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/tizen/i],
          describe: function describe(e) {
            var t = {
                name: "Tizen"
              },
              r = i["default"].getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/qupzilla/i],
          describe: function describe(e) {
            var t = {
                name: "QupZilla"
              },
              r = i["default"].getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/firefox|iceweasel|fxios/i],
          describe: function describe(e) {
            var t = {
                name: "Firefox"
              },
              r = i["default"].getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/electron/i],
          describe: function describe(e) {
            var t = {
                name: "Electron"
              },
              r = i["default"].getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/MiuiBrowser/i],
          describe: function describe(e) {
            var t = {
                name: "Miui"
              },
              r = i["default"].getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/chromium/i],
          describe: function describe(e) {
            var t = {
                name: "Chromium"
              },
              r = i["default"].getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/chrome|crios|crmo/i],
          describe: function describe(e) {
            var t = {
                name: "Chrome"
              },
              r = i["default"].getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/GSA/i],
          describe: function describe(e) {
            var t = {
                name: "Google Search"
              },
              r = i["default"].getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
            return r && (t.version = r), t;
          }
        }, {
          test: function test(e) {
            var t = !e.test(/like android/i),
              r = e.test(/android/i);
            return t && r;
          },
          describe: function describe(e) {
            var t = {
                name: "Android Browser"
              },
              r = i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/playstation 4/i],
          describe: function describe(e) {
            var t = {
                name: "PlayStation 4"
              },
              r = i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/safari|applewebkit/i],
          describe: function describe(e) {
            var t = {
                name: "Safari"
              },
              r = i["default"].getFirstMatch(s, e);
            return r && (t.version = r), t;
          }
        }, {
          test: [/.*/i],
          describe: function describe(e) {
            var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
            return {
              name: i["default"].getFirstMatch(t, e),
              version: i["default"].getSecondMatch(t, e)
            };
          }
        }];
      t["default"] = a, e.exports = t["default"];
    },
    93: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n,
        i = (n = r(17)) && n.__esModule ? n : {
          "default": n
        },
        s = r(18);
      var a = [{
        test: [/Roku\/DVP/],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
          return {
            name: s.OS_MAP.Roku,
            version: t
          };
        }
      }, {
        test: [/windows phone/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
          return {
            name: s.OS_MAP.WindowsPhone,
            version: t
          };
        }
      }, {
        test: [/windows /i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
            r = i["default"].getWindowsVersionName(t);
          return {
            name: s.OS_MAP.Windows,
            version: t,
            versionName: r
          };
        }
      }, {
        test: [/Macintosh(.*?) FxiOS(.*?)\//],
        describe: function describe(e) {
          var t = {
              name: s.OS_MAP.iOS
            },
            r = i["default"].getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
          return r && (t.version = r), t;
        }
      }, {
        test: [/macintosh/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
            r = i["default"].getMacOSVersionName(t),
            n = {
              name: s.OS_MAP.MacOS,
              version: t
            };
          return r && (n.versionName = r), n;
        }
      }, {
        test: [/(ipod|iphone|ipad)/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
          return {
            name: s.OS_MAP.iOS,
            version: t
          };
        }
      }, {
        test: function test(e) {
          var t = !e.test(/like android/i),
            r = e.test(/android/i);
          return t && r;
        },
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
            r = i["default"].getAndroidVersionName(t),
            n = {
              name: s.OS_MAP.Android,
              version: t
            };
          return r && (n.versionName = r), n;
        }
      }, {
        test: [/(web|hpw)[o0]s/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
            r = {
              name: s.OS_MAP.WebOS
            };
          return t && t.length && (r.version = t), r;
        }
      }, {
        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || i["default"].getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || i["default"].getFirstMatch(/\bbb(\d+)/i, e);
          return {
            name: s.OS_MAP.BlackBerry,
            version: t
          };
        }
      }, {
        test: [/bada/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
          return {
            name: s.OS_MAP.Bada,
            version: t
          };
        }
      }, {
        test: [/tizen/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
          return {
            name: s.OS_MAP.Tizen,
            version: t
          };
        }
      }, {
        test: [/linux/i],
        describe: function describe() {
          return {
            name: s.OS_MAP.Linux
          };
        }
      }, {
        test: [/CrOS/],
        describe: function describe() {
          return {
            name: s.OS_MAP.ChromeOS
          };
        }
      }, {
        test: [/PlayStation 4/],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
          return {
            name: s.OS_MAP.PlayStation4,
            version: t
          };
        }
      }];
      t["default"] = a, e.exports = t["default"];
    },
    94: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n,
        i = (n = r(17)) && n.__esModule ? n : {
          "default": n
        },
        s = r(18);
      var a = [{
        test: [/googlebot/i],
        describe: function describe() {
          return {
            type: "bot",
            vendor: "Google"
          };
        }
      }, {
        test: [/huawei/i],
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/(can-l01)/i, e) && "Nova",
            r = {
              type: s.PLATFORMS_MAP.mobile,
              vendor: "Huawei"
            };
          return t && (r.model = t), r;
        }
      }, {
        test: [/nexus\s*(?:7|8|9|10).*/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet,
            vendor: "Nexus"
          };
        }
      }, {
        test: [/ipad/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet,
            vendor: "Apple",
            model: "iPad"
          };
        }
      }, {
        test: [/Macintosh(.*?) FxiOS(.*?)\//],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet,
            vendor: "Apple",
            model: "iPad"
          };
        }
      }, {
        test: [/kftt build/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet,
            vendor: "Amazon",
            model: "Kindle Fire HD 7"
          };
        }
      }, {
        test: [/silk/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet,
            vendor: "Amazon"
          };
        }
      }, {
        test: [/tablet(?! pc)/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet
          };
        }
      }, {
        test: function test(e) {
          var t = e.test(/ipod|iphone/i),
            r = e.test(/like (ipod|iphone)/i);
          return t && !r;
        },
        describe: function describe(e) {
          var t = i["default"].getFirstMatch(/(ipod|iphone)/i, e);
          return {
            type: s.PLATFORMS_MAP.mobile,
            vendor: "Apple",
            model: t
          };
        }
      }, {
        test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.mobile,
            vendor: "Nexus"
          };
        }
      }, {
        test: [/[^-]mobi/i],
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.mobile
          };
        }
      }, {
        test: function test(e) {
          return "blackberry" === e.getBrowserName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.mobile,
            vendor: "BlackBerry"
          };
        }
      }, {
        test: function test(e) {
          return "bada" === e.getBrowserName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.mobile
          };
        }
      }, {
        test: function test(e) {
          return "windows phone" === e.getBrowserName();
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.mobile,
            vendor: "Microsoft"
          };
        }
      }, {
        test: function test(e) {
          var t = Number(String(e.getOSVersion()).split(".")[0]);
          return "android" === e.getOSName(!0) && t >= 3;
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tablet
          };
        }
      }, {
        test: function test(e) {
          return "android" === e.getOSName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.mobile
          };
        }
      }, {
        test: function test(e) {
          return "macos" === e.getOSName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.desktop,
            vendor: "Apple"
          };
        }
      }, {
        test: function test(e) {
          return "windows" === e.getOSName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.desktop
          };
        }
      }, {
        test: function test(e) {
          return "linux" === e.getOSName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.desktop
          };
        }
      }, {
        test: function test(e) {
          return "playstation 4" === e.getOSName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tv
          };
        }
      }, {
        test: function test(e) {
          return "roku" === e.getOSName(!0);
        },
        describe: function describe() {
          return {
            type: s.PLATFORMS_MAP.tv
          };
        }
      }];
      t["default"] = a, e.exports = t["default"];
    },
    95: function _(e, t, r) {
      "use strict";

      t.__esModule = !0, t["default"] = void 0;
      var n,
        i = (n = r(17)) && n.__esModule ? n : {
          "default": n
        },
        s = r(18);
      var a = [{
        test: function test(e) {
          return "microsoft edge" === e.getBrowserName(!0);
        },
        describe: function describe(e) {
          if (/\sedg\//i.test(e)) return {
            name: s.ENGINE_MAP.Blink
          };
          var t = i["default"].getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
          return {
            name: s.ENGINE_MAP.EdgeHTML,
            version: t
          };
        }
      }, {
        test: [/trident/i],
        describe: function describe(e) {
          var t = {
              name: s.ENGINE_MAP.Trident
            },
            r = i["default"].getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
          return r && (t.version = r), t;
        }
      }, {
        test: function test(e) {
          return e.test(/presto/i);
        },
        describe: function describe(e) {
          var t = {
              name: s.ENGINE_MAP.Presto
            },
            r = i["default"].getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
          return r && (t.version = r), t;
        }
      }, {
        test: function test(e) {
          var t = e.test(/gecko/i),
            r = e.test(/like gecko/i);
          return t && !r;
        },
        describe: function describe(e) {
          var t = {
              name: s.ENGINE_MAP.Gecko
            },
            r = i["default"].getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
          return r && (t.version = r), t;
        }
      }, {
        test: [/(apple)?webkit\/537\.36/i],
        describe: function describe() {
          return {
            name: s.ENGINE_MAP.Blink
          };
        }
      }, {
        test: [/(apple)?webkit/i],
        describe: function describe(e) {
          var t = {
              name: s.ENGINE_MAP.WebKit
            },
            r = i["default"].getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
          return r && (t.version = r), t;
        }
      }];
      t["default"] = a, e.exports = t["default"];
    }
  });
});

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || function () {};

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  var r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    var hash = 0;
    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      var self = debug;

      // Set `diff` timestamp
      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        var formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }
    var i;
    var len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

/***/ }),

/***/ "./node_modules/h264-profile-level-id/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/h264-profile-level-id/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('h264-profile-level-id');

/* eslint-disable no-console */
debug.log = console.info.bind(console);
/* eslint-enable no-console */

var ProfileConstrainedBaseline = 1;
var ProfileBaseline = 2;
var ProfileMain = 3;
var ProfileConstrainedHigh = 4;
var ProfileHigh = 5;
exports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;
exports.ProfileBaseline = ProfileBaseline;
exports.ProfileMain = ProfileMain;
exports.ProfileConstrainedHigh = ProfileConstrainedHigh;
exports.ProfileHigh = ProfileHigh;

// All values are equal to ten times the level number, except level 1b which is
// special.
var Level1_b = 0;
var Level1 = 10;
var Level1_1 = 11;
var Level1_2 = 12;
var Level1_3 = 13;
var Level2 = 20;
var Level2_1 = 21;
var Level2_2 = 22;
var Level3 = 30;
var Level3_1 = 31;
var Level3_2 = 32;
var Level4 = 40;
var Level4_1 = 41;
var Level4_2 = 42;
var Level5 = 50;
var Level5_1 = 51;
var Level5_2 = 52;
exports.Level1_b = Level1_b;
exports.Level1 = Level1;
exports.Level1_1 = Level1_1;
exports.Level1_2 = Level1_2;
exports.Level1_3 = Level1_3;
exports.Level2 = Level2;
exports.Level2_1 = Level2_1;
exports.Level2_2 = Level2_2;
exports.Level3 = Level3;
exports.Level3_1 = Level3_1;
exports.Level3_2 = Level3_2;
exports.Level4 = Level4;
exports.Level4_1 = Level4_1;
exports.Level4_2 = Level4_2;
exports.Level5 = Level5;
exports.Level5_1 = Level5_1;
exports.Level5_2 = Level5_2;
var ProfileLevelId = /*#__PURE__*/_createClass(function ProfileLevelId(profile, level) {
  _classCallCheck(this, ProfileLevelId);
  this.profile = profile;
  this.level = level;
});
exports.ProfileLevelId = ProfileLevelId;

// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
var DefaultProfileLevelId = new ProfileLevelId(ProfileConstrainedBaseline, Level3_1);

// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
// flag specifies if level 1b or level 1.1 is used.
var ConstraintSet3Flag = 0x10;

// Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to be
// either 0 or 1.
var BitPattern = /*#__PURE__*/function () {
  function BitPattern(str) {
    _classCallCheck(this, BitPattern);
    this._mask = ~byteMaskString('x', str);
    this._maskedValue = byteMaskString('1', str);
  }
  _createClass(BitPattern, [{
    key: "isMatch",
    value: function isMatch(value) {
      return this._maskedValue === (value & this._mask);
    }
  }]);
  return BitPattern;
}(); // Class for converting between profile_idc/profile_iop to Profile.
var ProfilePattern = /*#__PURE__*/_createClass(function ProfilePattern(profile_idc, profile_iop, profile) {
  _classCallCheck(this, ProfilePattern);
  this.profile_idc = profile_idc;
  this.profile_iop = profile_iop;
  this.profile = profile;
}); // This is from https://tools.ietf.org/html/rfc6184#section-8.1.
var ProfilePatterns = [new ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline), new ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline), new ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain), new ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh), new ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)];

/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 *
 * @param {String} str - profile-level-id value as a string of 3 hex bytes.
 *
 * @returns {ProfileLevelId}
 */
exports.parseProfileLevelId = function (str) {
  // The string should consist of 3 bytes in hexadecimal format.
  if (typeof str !== 'string' || str.length !== 6) return null;
  var profile_level_id_numeric = parseInt(str, 16);
  if (profile_level_id_numeric === 0) return null;

  // Separate into three bytes.
  var level_idc = profile_level_id_numeric & 0xFF;
  var profile_iop = profile_level_id_numeric >> 8 & 0xFF;
  var profile_idc = profile_level_id_numeric >> 16 & 0xFF;

  // Parse level based on level_idc and constraint set 3 flag.
  var level;
  switch (level_idc) {
    case Level1_1:
      {
        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;
        break;
      }
    case Level1:
    case Level1_2:
    case Level1_3:
    case Level2:
    case Level2_1:
    case Level2_2:
    case Level3:
    case Level3_1:
    case Level3_2:
    case Level4:
    case Level4_1:
    case Level4_2:
    case Level5:
    case Level5_1:
    case Level5_2:
      {
        level = level_idc;
        break;
      }
    // Unrecognized level_idc.
    default:
      {
        debug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);
        return null;
      }
  }

  // Parse profile_idc/profile_iop into a Profile enum.
  for (var _i = 0, _ProfilePatterns = ProfilePatterns; _i < _ProfilePatterns.length; _i++) {
    var pattern = _ProfilePatterns[_i];
    if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
      return new ProfileLevelId(pattern.profile, level);
    }
  }
  debug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');
  return null;
};

/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 *
 * @param {ProfileLevelId} profile_level_id
 *
 * @returns {String}
 */
exports.profileLevelIdToString = function (profile_level_id) {
  // Handle special case level == 1b.
  if (profile_level_id.level == Level1_b) {
    switch (profile_level_id.profile) {
      case ProfileConstrainedBaseline:
        {
          return '42f00b';
        }
      case ProfileBaseline:
        {
          return '42100b';
        }
      case ProfileMain:
        {
          return '4d100b';
        }
      // Level 1_b is not allowed for other profiles.
      default:
        {
          debug('profileLevelIdToString() | Level 1_b not is allowed for profile:%s', profile_level_id.profile);
          return null;
        }
    }
  }
  var profile_idc_iop_string;
  switch (profile_level_id.profile) {
    case ProfileConstrainedBaseline:
      {
        profile_idc_iop_string = '42e0';
        break;
      }
    case ProfileBaseline:
      {
        profile_idc_iop_string = '4200';
        break;
      }
    case ProfileMain:
      {
        profile_idc_iop_string = '4d00';
        break;
      }
    case ProfileConstrainedHigh:
      {
        profile_idc_iop_string = '640c';
        break;
      }
    case ProfileHigh:
      {
        profile_idc_iop_string = '6400';
        break;
      }
    default:
      {
        debug('profileLevelIdToString() | unrecognized profile:%s', profile_level_id.profile);
        return null;
      }
  }
  var levelStr = profile_level_id.level.toString(16);
  if (levelStr.length === 1) levelStr = "0".concat(levelStr);
  return "".concat(profile_idc_iop_string).concat(levelStr);
};

/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned if
 * the key is present but the string is invalid.
 *
 * @param {Object} [params={}] - Codec parameters object.
 *
 * @returns {ProfileLevelId}
 */
exports.parseSdpProfileLevelId = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var profile_level_id = params['profile-level-id'];
  return !profile_level_id ? DefaultProfileLevelId : exports.parseProfileLevelId(profile_level_id);
};

/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 *
 * @param {Object} [params1={}] - Codec parameters object.
 * @param {Object} [params2={}] - Codec parameters object.
 *
 * @returns {Boolean}
 */
exports.isSameProfile = function () {
  var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var profile_level_id_1 = exports.parseSdpProfileLevelId(params1);
  var profile_level_id_2 = exports.parseSdpProfileLevelId(params2);

  // Compare H264 profiles, but not levels.
  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
};

/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict superset
 * of the profile in remote_offered_params, we could limit the profile in the
 * answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and level-asymmetry-allowed.
 *
 * @param {Object} [local_supported_params={}]
 * @param {Object} [remote_offered_params={}]
 *
 * @returns {String} Canonical string representation as three hex bytes of the
 *   profile level id, or null if no one of the params have profile-level-id.
 *
 * @throws {TypeError} If Profile mismatch or invalid params.
 */
exports.generateProfileLevelIdForAnswer = function () {
  var local_supported_params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var remote_offered_params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // If both local and remote params do not contain profile-level-id, they are
  // both using the default profile. In this case, don't return anything.
  if (!local_supported_params['profile-level-id'] && !remote_offered_params['profile-level-id']) {
    debug('generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');
    return null;
  }

  // Parse profile-level-ids.
  var local_profile_level_id = exports.parseSdpProfileLevelId(local_supported_params);
  var remote_profile_level_id = exports.parseSdpProfileLevelId(remote_offered_params);

  // The local and remote codec must have valid and equal H264 Profiles.
  if (!local_profile_level_id) throw new TypeError('invalid local_profile_level_id');
  if (!remote_profile_level_id) throw new TypeError('invalid remote_profile_level_id');
  if (local_profile_level_id.profile !== remote_profile_level_id.profile) throw new TypeError('H264 Profile mismatch');

  // Parse level information.
  var level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
  var local_level = local_profile_level_id.level;
  var remote_level = remote_profile_level_id.level;
  var min_level = minLevel(local_level, remote_level);

  // Determine answer level. When level asymmetry is not allowed, level upgrade
  // is not allowed, i.e., the level in the answer must be equal to or lower
  // than the level in the offer.
  var answer_level = level_asymmetry_allowed ? local_level : min_level;
  debug('generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]', local_profile_level_id.profile, answer_level);

  // Return the resulting profile-level-id for the answer parameters.
  return exports.profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
};

// Convert a string of 8 characters into a byte where the positions containing
// character c will have their bit set. For example, c = 'x', str = "x1xx0000"
// will return 0b10110000.
function byteMaskString(c, str) {
  return (str[0] === c) << 7 | (str[1] === c) << 6 | (str[2] === c) << 5 | (str[3] === c) << 4 | (str[4] === c) << 3 | (str[5] === c) << 2 | (str[6] === c) << 1 | (str[7] === c) << 0;
}

// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
  if (a === Level1_b) return b !== Level1 && b !== Level1_b;
  if (b === Level1_b) return a !== Level1;
  return a < b;
}
function minLevel(a, b) {
  return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var level_asymmetry_allowed = params['level-asymmetry-allowed'];
  return level_asymmetry_allowed === 1 || level_asymmetry_allowed === '1';
}

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Consumer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Consumer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Consumer = void 0;
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
var logger = new Logger_1.Logger('Consumer');
var Consumer = /*#__PURE__*/function (_EnhancedEventEmitter) {
  _inherits(Consumer, _EnhancedEventEmitter);
  var _super = _createSuper(Consumer);
  function Consumer(_ref) {
    var _this;
    var id = _ref.id,
      localId = _ref.localId,
      producerId = _ref.producerId,
      rtpReceiver = _ref.rtpReceiver,
      track = _ref.track,
      rtpParameters = _ref.rtpParameters,
      appData = _ref.appData;
    _classCallCheck(this, Consumer);
    _this = _super.call(this);
    // Closed flag.
    _this._closed = false;
    // Observer instance.
    _this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    logger.debug('constructor()');
    _this._id = id;
    _this._localId = localId;
    _this._producerId = producerId;
    _this._rtpReceiver = rtpReceiver;
    _this._track = track;
    _this._rtpParameters = rtpParameters;
    _this._paused = !track.enabled;
    _this._appData = appData || {};
    _this.onTrackEnded = _this.onTrackEnded.bind(_assertThisInitialized(_this));
    _this.handleTrack();
    return _this;
  }
  /**
   * Consumer id.
   */
  _createClass(Consumer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Local id.
     */
  }, {
    key: "localId",
    get: function get() {
      return this._localId;
    }
    /**
     * Associated Producer id.
     */
  }, {
    key: "producerId",
    get: function get() {
      return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Media kind.
     */
  }, {
    key: "kind",
    get: function get() {
      return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
  }, {
    key: "rtpReceiver",
    get: function get() {
      return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
  }, {
    key: "track",
    get: function get() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
  }, {
    key: "rtpParameters",
    get: function get() {
      return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * Invalid setter.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ,

    set: function set(appData) {
      throw new Error('cannot override appData object');
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the Consumer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) return;
      logger.debug('close()');
      this._closed = true;
      this.destroyTrack();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) return;
      logger.debug('transportClosed()');
      this._closed = true;
      this.destroyTrack();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
  }, {
    key: "getStats",
    value: function () {
      var _getStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this._closed) {
                _context.next = 2;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 2:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                _this2.safeEmit('@getstats', resolve, reject);
              }));
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Pauses receiving media.
     */
  }, {
    key: "pause",
    value: function pause() {
      logger.debug('pause()');
      if (this._closed) {
        logger.error('pause() | Consumer closed');
        return;
      }
      if (this._paused) {
        logger.debug('pause() | Consumer is already paused');
        return;
      }
      this._paused = true;
      this._track.enabled = false;
      this.emit('@pause');
      // Emit observer event.
      this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
  }, {
    key: "resume",
    value: function resume() {
      logger.debug('resume()');
      if (this._closed) {
        logger.error('resume() | Consumer closed');
        return;
      }
      if (!this._paused) {
        logger.debug('resume() | Consumer is already resumed');
        return;
      }
      this._paused = false;
      this._track.enabled = true;
      this.emit('@resume');
      // Emit observer event.
      this._observer.safeEmit('resume');
    }
  }, {
    key: "onTrackEnded",
    value: function onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit('trackended');
      // Emit observer event.
      this._observer.safeEmit('trackended');
    }
  }, {
    key: "handleTrack",
    value: function handleTrack() {
      this._track.addEventListener('ended', this.onTrackEnded);
    }
  }, {
    key: "destroyTrack",
    value: function destroyTrack() {
      try {
        this._track.removeEventListener('ended', this.onTrackEnded);
        this._track.stop();
      } catch (error) {}
    }
  }]);
  return Consumer;
}(EnhancedEventEmitter_1.EnhancedEventEmitter);
exports.Consumer = Consumer;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataConsumer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataConsumer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DataConsumer = void 0;
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var logger = new Logger_1.Logger('DataConsumer');
var DataConsumer = /*#__PURE__*/function (_EnhancedEventEmitter) {
  _inherits(DataConsumer, _EnhancedEventEmitter);
  var _super = _createSuper(DataConsumer);
  function DataConsumer(_ref) {
    var _this;
    var id = _ref.id,
      dataProducerId = _ref.dataProducerId,
      dataChannel = _ref.dataChannel,
      sctpStreamParameters = _ref.sctpStreamParameters,
      appData = _ref.appData;
    _classCallCheck(this, DataConsumer);
    _this = _super.call(this);
    // Closed flag.
    _this._closed = false;
    // Observer instance.
    _this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    logger.debug('constructor()');
    _this._id = id;
    _this._dataProducerId = dataProducerId;
    _this._dataChannel = dataChannel;
    _this._sctpStreamParameters = sctpStreamParameters;
    _this._appData = appData || {};
    _this.handleDataChannel();
    return _this;
  }
  /**
   * DataConsumer id.
   */
  _createClass(DataConsumer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Associated DataProducer id.
     */
  }, {
    key: "dataProducerId",
    get: function get() {
      return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
  }, {
    key: "sctpStreamParameters",
    get: function get() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
  }, {
    key: "readyState",
    get: function get() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
  }, {
    key: "label",
    get: function get() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
  }, {
    key: "protocol",
    get: function get() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
  }, {
    key: "binaryType",
    get: function get() {
      return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */,
    set: function set(binaryType) {
      this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * Invalid setter.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ,

    set: function set(appData) {
      throw new Error('cannot override appData object');
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) return;
      logger.debug('close()');
      this._closed = true;
      this._dataChannel.close();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) return;
      logger.debug('transportClosed()');
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
  }, {
    key: "handleDataChannel",
    value: function handleDataChannel() {
      var _this2 = this;
      this._dataChannel.addEventListener('open', function () {
        if (_this2._closed) return;
        logger.debug('DataChannel "open" event');
        _this2.safeEmit('open');
      });
      this._dataChannel.addEventListener('error', function (event) {
        if (_this2._closed) return;
        var error = event.error;
        if (!error) error = new Error('unknown DataChannel error');
        if (error.errorDetail === 'sctp-failure') {
          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        _this2.safeEmit('error', error);
      });
      this._dataChannel.addEventListener('close', function () {
        if (_this2._closed) return;
        logger.warn('DataChannel "close" event');
        _this2._closed = true;
        _this2.emit('@close');
        _this2.safeEmit('close');
        // Emit observer event.
        _this2._observer.safeEmit('close');
      });
      this._dataChannel.addEventListener('message', function (event) {
        if (_this2._closed) return;
        _this2.safeEmit('message', event.data);
      });
    }
  }]);
  return DataConsumer;
}(EnhancedEventEmitter_1.EnhancedEventEmitter);
exports.DataConsumer = DataConsumer;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataProducer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataProducer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DataProducer = void 0;
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
var logger = new Logger_1.Logger('DataProducer');
var DataProducer = /*#__PURE__*/function (_EnhancedEventEmitter) {
  _inherits(DataProducer, _EnhancedEventEmitter);
  var _super = _createSuper(DataProducer);
  function DataProducer(_ref) {
    var _this;
    var id = _ref.id,
      dataChannel = _ref.dataChannel,
      sctpStreamParameters = _ref.sctpStreamParameters,
      appData = _ref.appData;
    _classCallCheck(this, DataProducer);
    _this = _super.call(this);
    // Closed flag.
    _this._closed = false;
    // Observer instance.
    _this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    logger.debug('constructor()');
    _this._id = id;
    _this._dataChannel = dataChannel;
    _this._sctpStreamParameters = sctpStreamParameters;
    _this._appData = appData || {};
    _this.handleDataChannel();
    return _this;
  }
  /**
   * DataProducer id.
   */
  _createClass(DataProducer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
  }, {
    key: "sctpStreamParameters",
    get: function get() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
  }, {
    key: "readyState",
    get: function get() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
  }, {
    key: "label",
    get: function get() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
  }, {
    key: "protocol",
    get: function get() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
  }, {
    key: "bufferedAmount",
    get: function get() {
      return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
  }, {
    key: "bufferedAmountLowThreshold",
    get: function get() {
      return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */,
    set: function set(bufferedAmountLowThreshold) {
      this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * Invalid setter.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ,

    set: function set(appData) {
      throw new Error('cannot override appData object');
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) return;
      logger.debug('close()');
      this._closed = true;
      this._dataChannel.close();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) return;
      logger.debug('transportClosed()');
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
  }, {
    key: "send",
    value: function send(data) {
      logger.debug('send()');
      if (this._closed) throw new errors_1.InvalidStateError('closed');
      this._dataChannel.send(data);
    }
  }, {
    key: "handleDataChannel",
    value: function handleDataChannel() {
      var _this2 = this;
      this._dataChannel.addEventListener('open', function () {
        if (_this2._closed) return;
        logger.debug('DataChannel "open" event');
        _this2.safeEmit('open');
      });
      this._dataChannel.addEventListener('error', function (event) {
        if (_this2._closed) return;
        var error = event.error;
        if (!error) error = new Error('unknown DataChannel error');
        if (error.errorDetail === 'sctp-failure') {
          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        _this2.safeEmit('error', error);
      });
      this._dataChannel.addEventListener('close', function () {
        if (_this2._closed) return;
        logger.warn('DataChannel "close" event');
        _this2._closed = true;
        _this2.emit('@close');
        _this2.safeEmit('close');
        // Emit observer event.
        _this2._observer.safeEmit('close');
      });
      this._dataChannel.addEventListener('message', function () {
        if (_this2._closed) return;
        logger.warn('DataChannel "message" event in a DataProducer, message discarded');
      });
      this._dataChannel.addEventListener('bufferedamountlow', function () {
        if (_this2._closed) return;
        _this2.safeEmit('bufferedamountlow');
      });
    }
  }]);
  return DataProducer;
}(EnhancedEventEmitter_1.EnhancedEventEmitter);
exports.DataProducer = DataProducer;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Device.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Device.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Device = exports.detectDevice = void 0;
var bowser_1 = __importDefault(__webpack_require__(/*! bowser */ "./node_modules/bowser/es5.js"));
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
var utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ./ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var Transport_1 = __webpack_require__(/*! ./Transport */ "./node_modules/mediasoup-client/lib/Transport.js");
var Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ "./node_modules/mediasoup-client/lib/handlers/Chrome74.js");
var Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ "./node_modules/mediasoup-client/lib/handlers/Chrome70.js");
var Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ "./node_modules/mediasoup-client/lib/handlers/Chrome67.js");
var Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ "./node_modules/mediasoup-client/lib/handlers/Chrome55.js");
var Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ "./node_modules/mediasoup-client/lib/handlers/Firefox60.js");
var Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ "./node_modules/mediasoup-client/lib/handlers/Safari12.js");
var Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ "./node_modules/mediasoup-client/lib/handlers/Safari11.js");
var Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ "./node_modules/mediasoup-client/lib/handlers/Edge11.js");
var ReactNativeUnifiedPlan_1 = __webpack_require__(/*! ./handlers/ReactNativeUnifiedPlan */ "./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js");
var ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ "./node_modules/mediasoup-client/lib/handlers/ReactNative.js");
var logger = new Logger_1.Logger('Device');
function detectDevice() {
  // React-Native.
  // NOTE: react-native-webrtc >= 1.75.0 is required.
  // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.product === 'ReactNative') {
    if (typeof RTCPeerConnection === 'undefined') {
      logger.warn('this._detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?');
      return undefined;
    }
    if (typeof RTCRtpTransceiver !== 'undefined') {
      logger.debug('this._detectDevice() | ReactNative UnifiedPlan handler chosen');
      return 'ReactNativeUnifiedPlan';
    } else {
      logger.debug('this._detectDevice() | ReactNative PlanB handler chosen');
      return 'ReactNative';
    }
  }
  // Browser.
  else if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && typeof navigator.userAgent === 'string') {
    var ua = navigator.userAgent;
    var browser = bowser_1["default"].getParser(ua);
    var engine = browser.getEngine();
    // Chrome, Chromium, and Edge.
    if (browser.satisfies({
      chrome: '>=74',
      chromium: '>=74',
      'microsoft edge': '>=88'
    })) {
      return 'Chrome74';
    } else if (browser.satisfies({
      chrome: '>=70',
      chromium: '>=70'
    })) {
      return 'Chrome70';
    } else if (browser.satisfies({
      chrome: '>=67',
      chromium: '>=67'
    })) {
      return 'Chrome67';
    } else if (browser.satisfies({
      chrome: '>=55',
      chromium: '>=55'
    })) {
      return 'Chrome55';
    }
    // Firefox.
    else if (browser.satisfies({
      firefox: '>=60'
    })) {
      return 'Firefox60';
    }
    // Firefox on iOS.
    else if (browser.satisfies({
      ios: {
        OS: '>=14.3',
        firefox: '>=30.0'
      }
    })) {
      return 'Safari12';
    }
    // Safari with Unified-Plan support enabled.
    else if (browser.satisfies({
      safari: '>=12.0'
    }) && typeof RTCRtpTransceiver !== 'undefined' && RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
      return 'Safari12';
    }
    // Safari with Plab-B support.
    else if (browser.satisfies({
      safari: '>=11'
    })) {
      return 'Safari11';
    }
    // Old Edge with ORTC support.
    else if (browser.satisfies({
      'microsoft edge': '>=11'
    }) && browser.satisfies({
      'microsoft edge': '<=18'
    })) {
      return 'Edge11';
    }
    // Best effort for Chromium based browsers.
    else if (engine.name && engine.name.toLowerCase() === 'blink') {
      var match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
      if (match) {
        var version = Number(match[1]);
        if (version >= 74) {
          return 'Chrome74';
        } else if (version >= 70) {
          return 'Chrome70';
        } else if (version >= 67) {
          return 'Chrome67';
        } else {
          return 'Chrome55';
        }
      } else {
        return 'Chrome74';
      }
    }
    // Unsupported browser.
    else {
      logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());
      return undefined;
    }
  }
  // Unknown device.
  else {
    logger.warn('this._detectDevice() | unknown device');
    return undefined;
  }
}
exports.detectDevice = detectDevice;
var Device = /*#__PURE__*/function () {
  /**
   * Create a new Device to connect to mediasoup server.
   *
   * @throws {UnsupportedError} if device is not supported.
   */
  function Device() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      handlerName = _ref.handlerName,
      handlerFactory = _ref.handlerFactory,
      Handler = _ref.Handler;
    _classCallCheck(this, Device);
    // Loaded flag.
    this._loaded = false;
    // Observer instance.
    this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    logger.debug('constructor()');
    // Handle deprecated option.
    if (Handler) {
      logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');
      if (typeof Handler === 'string') {
        handlerName = Handler;
      } else {
        throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');
      }
    }
    if (handlerName && handlerFactory) {
      throw new TypeError('just one of handlerName or handlerInterface can be given');
    }
    if (handlerFactory) {
      this._handlerFactory = handlerFactory;
    } else {
      if (handlerName) {
        logger.debug('constructor() | handler given: %s', handlerName);
      } else {
        handlerName = detectDevice();
        if (handlerName) {
          logger.debug('constructor() | detected handler: %s', handlerName);
        } else {
          throw new errors_1.UnsupportedError('device not supported');
        }
      }
      switch (handlerName) {
        case 'Chrome74':
          this._handlerFactory = Chrome74_1.Chrome74.createFactory();
          break;
        case 'Chrome70':
          this._handlerFactory = Chrome70_1.Chrome70.createFactory();
          break;
        case 'Chrome67':
          this._handlerFactory = Chrome67_1.Chrome67.createFactory();
          break;
        case 'Chrome55':
          this._handlerFactory = Chrome55_1.Chrome55.createFactory();
          break;
        case 'Firefox60':
          this._handlerFactory = Firefox60_1.Firefox60.createFactory();
          break;
        case 'Safari12':
          this._handlerFactory = Safari12_1.Safari12.createFactory();
          break;
        case 'Safari11':
          this._handlerFactory = Safari11_1.Safari11.createFactory();
          break;
        case 'Edge11':
          this._handlerFactory = Edge11_1.Edge11.createFactory();
          break;
        case 'ReactNativeUnifiedPlan':
          this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
          break;
        case 'ReactNative':
          this._handlerFactory = ReactNative_1.ReactNative.createFactory();
          break;
        default:
          throw new TypeError("unknown handlerName \"".concat(handlerName, "\""));
      }
    }
    // Create a temporal handler to get its name.
    var handler = this._handlerFactory();
    this._handlerName = handler.name;
    handler.close();
    this._extendedRtpCapabilities = undefined;
    this._recvRtpCapabilities = undefined;
    this._canProduceByKind = {
      audio: false,
      video: false
    };
    this._sctpCapabilities = undefined;
  }
  /**
   * The RTC handler name.
   */
  _createClass(Device, [{
    key: "handlerName",
    get: function get() {
      return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
  }, {
    key: "loaded",
    get: function get() {
      return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
  }, {
    key: "rtpCapabilities",
    get: function get() {
      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');
      return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
  }, {
    key: "sctpCapabilities",
    get: function get() {
      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');
      return this._sctpCapabilities;
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Initialize the Device.
     */
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {
        var routerRtpCapabilities, handler, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              routerRtpCapabilities = _ref2.routerRtpCapabilities;
              logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
              routerRtpCapabilities = utils.clone(routerRtpCapabilities, undefined);
              // Temporal handler to get its capabilities.
              _context.prev = 3;
              if (!this._loaded) {
                _context.next = 6;
                break;
              }
              throw new errors_1.InvalidStateError('already loaded');
            case 6:
              // This may throw.
              ortc.validateRtpCapabilities(routerRtpCapabilities);
              handler = this._handlerFactory();
              _context.next = 10;
              return handler.getNativeRtpCapabilities();
            case 10:
              nativeRtpCapabilities = _context.sent;
              logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);
              // This may throw.
              ortc.validateRtpCapabilities(nativeRtpCapabilities);
              // Get extended RTP capabilities.
              this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);
              logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);
              // Check whether we can produce audio/video.
              this._canProduceByKind.audio = ortc.canSend('audio', this._extendedRtpCapabilities);
              this._canProduceByKind.video = ortc.canSend('video', this._extendedRtpCapabilities);
              // Generate our receiving RTP capabilities for receiving media.
              this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
              // This may throw.
              ortc.validateRtpCapabilities(this._recvRtpCapabilities);
              logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
              // Generate our SCTP capabilities.
              _context.next = 22;
              return handler.getNativeSctpCapabilities();
            case 22:
              this._sctpCapabilities = _context.sent;
              logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
              // This may throw.
              ortc.validateSctpCapabilities(this._sctpCapabilities);
              logger.debug('load() succeeded');
              this._loaded = true;
              handler.close();
              _context.next = 34;
              break;
            case 30:
              _context.prev = 30;
              _context.t0 = _context["catch"](3);
              if (handler) handler.close();
              throw _context.t0;
            case 34:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 30]]);
      }));
      function load(_x) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "canProduce",
    value: function canProduce(kind) {
      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');else if (kind !== 'audio' && kind !== 'video') throw new TypeError("invalid kind \"".concat(kind, "\""));
      return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "createSendTransport",
    value: function createSendTransport(_ref3) {
      var id = _ref3.id,
        iceParameters = _ref3.iceParameters,
        iceCandidates = _ref3.iceCandidates,
        dtlsParameters = _ref3.dtlsParameters,
        sctpParameters = _ref3.sctpParameters,
        iceServers = _ref3.iceServers,
        iceTransportPolicy = _ref3.iceTransportPolicy,
        additionalSettings = _ref3.additionalSettings,
        proprietaryConstraints = _ref3.proprietaryConstraints,
        appData = _ref3.appData;
      logger.debug('createSendTransport()');
      return this.createTransport({
        direction: 'send',
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        proprietaryConstraints: proprietaryConstraints,
        appData: appData
      });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
  }, {
    key: "createRecvTransport",
    value: function createRecvTransport(_ref4) {
      var id = _ref4.id,
        iceParameters = _ref4.iceParameters,
        iceCandidates = _ref4.iceCandidates,
        dtlsParameters = _ref4.dtlsParameters,
        sctpParameters = _ref4.sctpParameters,
        iceServers = _ref4.iceServers,
        iceTransportPolicy = _ref4.iceTransportPolicy,
        additionalSettings = _ref4.additionalSettings,
        proprietaryConstraints = _ref4.proprietaryConstraints,
        appData = _ref4.appData;
      logger.debug('createRecvTransport()');
      return this.createTransport({
        direction: 'recv',
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        proprietaryConstraints: proprietaryConstraints,
        appData: appData
      });
    }
  }, {
    key: "createTransport",
    value: function createTransport(_ref5) {
      var direction = _ref5.direction,
        id = _ref5.id,
        iceParameters = _ref5.iceParameters,
        iceCandidates = _ref5.iceCandidates,
        dtlsParameters = _ref5.dtlsParameters,
        sctpParameters = _ref5.sctpParameters,
        iceServers = _ref5.iceServers,
        iceTransportPolicy = _ref5.iceTransportPolicy,
        additionalSettings = _ref5.additionalSettings,
        proprietaryConstraints = _ref5.proprietaryConstraints,
        appData = _ref5.appData;
      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');else if (typeof id !== 'string') throw new TypeError('missing id');else if (_typeof(iceParameters) !== 'object') throw new TypeError('missing iceParameters');else if (!Array.isArray(iceCandidates)) throw new TypeError('missing iceCandidates');else if (_typeof(dtlsParameters) !== 'object') throw new TypeError('missing dtlsParameters');else if (sctpParameters && _typeof(sctpParameters) !== 'object') throw new TypeError('wrong sctpParameters');else if (appData && _typeof(appData) !== 'object') throw new TypeError('if given, appData must be an object');
      // Create a new Transport.
      var transport = new Transport_1.Transport({
        direction: direction,
        id: id,
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy,
        additionalSettings: additionalSettings,
        proprietaryConstraints: proprietaryConstraints,
        appData: appData,
        handlerFactory: this._handlerFactory,
        extendedRtpCapabilities: this._extendedRtpCapabilities,
        canProduceByKind: this._canProduceByKind
      });
      // Emit observer event.
      this._observer.safeEmit('newtransport', transport);
      return transport;
    }
  }]);
  return Device;
}();
exports.Device = Device;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EnhancedEventEmitter = void 0;
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var logger = new Logger_1.Logger('EnhancedEventEmitter');
var EnhancedEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(EnhancedEventEmitter, _events_1$EventEmitte);
  var _super = _createSuper(EnhancedEventEmitter);
  function EnhancedEventEmitter() {
    var _this;
    _classCallCheck(this, EnhancedEventEmitter);
    _this = _super.call(this);
    _this.setMaxListeners(Infinity);
    return _this;
  }
  _createClass(EnhancedEventEmitter, [{
    key: "emit",
    value: function emit(eventName) {
      var _get2;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return (_get2 = _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "emit", this)).call.apply(_get2, [this, eventName].concat(args));
    }
    /**
     * Special addition to the EventEmitter API.
     */
  }, {
    key: "safeEmit",
    value: function safeEmit(eventName) {
      var numListeners = _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "listenerCount", this).call(this, eventName);
      try {
        var _get3;
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return (_get3 = _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "emit", this)).call.apply(_get3, [this, eventName].concat(args));
      } catch (error) {
        logger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
        return Boolean(numListeners);
      }
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "on", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "off",
    value: function off(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "off", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "on", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "prependListener", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "once",
    value: function once(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "once", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "prependOnceListener", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "off", this).call(this, eventName, listener);
      return this;
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "removeAllListeners", this).call(this, eventName);
      return this;
    }
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName) {
      return _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "listenerCount", this).call(this, eventName);
    }
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      return _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "listeners", this).call(this, eventName);
    }
  }, {
    key: "rawListeners",
    value: function rawListeners(eventName) {
      return _get(_getPrototypeOf(EnhancedEventEmitter.prototype), "rawListeners", this).call(this, eventName);
    }
  }]);
  return EnhancedEventEmitter;
}(events_1.EventEmitter);
exports.EnhancedEventEmitter = EnhancedEventEmitter;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Logger.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Logger.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Logger = void 0;
var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
var APP_NAME = 'mediasoup-client';
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck(this, Logger);
    if (prefix) {
      this._debug = (0, debug_1["default"])("".concat(APP_NAME, ":").concat(prefix));
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN:").concat(prefix));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = (0, debug_1["default"])(APP_NAME);
      this._warn = (0, debug_1["default"])("".concat(APP_NAME, ":WARN"));
      this._error = (0, debug_1["default"])("".concat(APP_NAME, ":ERROR"));
    }
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  _createClass(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
  return Logger;
}();
exports.Logger = Logger;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Producer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Producer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Producer = void 0;
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
var logger = new Logger_1.Logger('Producer');
var Producer = /*#__PURE__*/function (_EnhancedEventEmitter) {
  _inherits(Producer, _EnhancedEventEmitter);
  var _super = _createSuper(Producer);
  function Producer(_ref) {
    var _this;
    var id = _ref.id,
      localId = _ref.localId,
      rtpSender = _ref.rtpSender,
      track = _ref.track,
      rtpParameters = _ref.rtpParameters,
      stopTracks = _ref.stopTracks,
      disableTrackOnPause = _ref.disableTrackOnPause,
      zeroRtpOnPause = _ref.zeroRtpOnPause,
      appData = _ref.appData;
    _classCallCheck(this, Producer);
    _this = _super.call(this);
    // Closed flag.
    _this._closed = false;
    // Observer instance.
    _this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    logger.debug('constructor()');
    _this._id = id;
    _this._localId = localId;
    _this._rtpSender = rtpSender;
    _this._track = track;
    _this._kind = track.kind;
    _this._rtpParameters = rtpParameters;
    _this._paused = disableTrackOnPause ? !track.enabled : false;
    _this._maxSpatialLayer = undefined;
    _this._stopTracks = stopTracks;
    _this._disableTrackOnPause = disableTrackOnPause;
    _this._zeroRtpOnPause = zeroRtpOnPause;
    _this._appData = appData || {};
    _this.onTrackEnded = _this.onTrackEnded.bind(_assertThisInitialized(_this));
    // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
    // '@replacetrack' event here, so RTCRtpSender.track won't be null.
    _this.handleTrack();
    return _this;
  }
  /**
   * Producer id.
   */
  _createClass(Producer, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Local id.
     */
  }, {
    key: "localId",
    get: function get() {
      return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Media kind.
     */
  }, {
    key: "kind",
    get: function get() {
      return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
  }, {
    key: "rtpSender",
    get: function get() {
      return this._rtpSender;
    }
    /**
     * The associated track.
     */
  }, {
    key: "track",
    get: function get() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
  }, {
    key: "rtpParameters",
    get: function get() {
      return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
  }, {
    key: "paused",
    get: function get() {
      return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
  }, {
    key: "maxSpatialLayer",
    get: function get() {
      return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * Invalid setter.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ,

    set: function set(appData) {
      throw new Error('cannot override appData object');
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Closes the Producer.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) return;
      logger.debug('close()');
      this._closed = true;
      this.destroyTrack();
      this.emit('@close');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
  }, {
    key: "transportClosed",
    value: function transportClosed() {
      if (this._closed) return;
      logger.debug('transportClosed()');
      this._closed = true;
      this.destroyTrack();
      this.safeEmit('transportclose');
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
  }, {
    key: "getStats",
    value: function () {
      var _getStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this._closed) {
                _context.next = 2;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 2:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                _this2.safeEmit('@getstats', resolve, reject);
              }));
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Pauses sending media.
     */
  }, {
    key: "pause",
    value: function pause() {
      var _this3 = this;
      logger.debug('pause()');
      if (this._closed) {
        logger.error('pause() | Producer closed');
        return;
      }
      this._paused = true;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = false;
      }
      if (this._zeroRtpOnPause) {
        new Promise(function (resolve, reject) {
          _this3.safeEmit('@pause', resolve, reject);
        })["catch"](function () {});
      }
      // Emit observer event.
      this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
  }, {
    key: "resume",
    value: function resume() {
      var _this4 = this;
      logger.debug('resume()');
      if (this._closed) {
        logger.error('resume() | Producer closed');
        return;
      }
      this._paused = false;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = true;
      }
      if (this._zeroRtpOnPause) {
        new Promise(function (resolve, reject) {
          _this4.safeEmit('@resume', resolve, reject);
        })["catch"](function () {});
      }
      // Emit observer event.
      this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {
        var _this5 = this;
        var track;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              track = _ref2.track;
              logger.debug('replaceTrack() [track:%o]', track);
              if (!this._closed) {
                _context2.next = 7;
                break;
              }
              // This must be done here. Otherwise there is no chance to stop the given
              // track.
              if (track && this._stopTracks) {
                try {
                  track.stop();
                } catch (error) {}
              }
              throw new errors_1.InvalidStateError('closed');
            case 7:
              if (!(track && track.readyState === 'ended')) {
                _context2.next = 9;
                break;
              }
              throw new errors_1.InvalidStateError('track ended');
            case 9:
              if (!(track === this._track)) {
                _context2.next = 12;
                break;
              }
              logger.debug('replaceTrack() | same track, ignored');
              return _context2.abrupt("return");
            case 12:
              _context2.next = 14;
              return new Promise(function (resolve, reject) {
                _this5.safeEmit('@replacetrack', track, resolve, reject);
              });
            case 14:
              // Destroy the previous track.
              this.destroyTrack();
              // Set the new track.
              this._track = track;
              // If this Producer was paused/resumed and the state of the new
              // track does not match, fix it.
              if (this._track && this._disableTrackOnPause) {
                if (!this._paused) this._track.enabled = true;else if (this._paused) this._track.enabled = false;
              }
              // Handle the effective track.
              this.handleTrack();
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function replaceTrack(_x) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
    /**
     * Sets the video max spatial layer to be sent.
     */
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(spatialLayer) {
        var _this6 = this;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!this._closed) {
                _context3.next = 4;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 4:
              if (!(this._kind !== 'video')) {
                _context3.next = 8;
                break;
              }
              throw new errors_1.UnsupportedError('not a video Producer');
            case 8:
              if (!(typeof spatialLayer !== 'number')) {
                _context3.next = 10;
                break;
              }
              throw new TypeError('invalid spatialLayer');
            case 10:
              if (!(spatialLayer === this._maxSpatialLayer)) {
                _context3.next = 12;
                break;
              }
              return _context3.abrupt("return");
            case 12:
              _context3.next = 14;
              return new Promise(function (resolve, reject) {
                _this6.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);
              })["catch"](function () {});
            case 14:
              this._maxSpatialLayer = spatialLayer;
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function setMaxSpatialLayer(_x2) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
        var _this7 = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!this._closed) {
                _context4.next = 4;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 4:
              if (!(_typeof(params) !== 'object')) {
                _context4.next = 6;
                break;
              }
              throw new TypeError('invalid params');
            case 6:
              _context4.next = 8;
              return new Promise(function (resolve, reject) {
                _this7.safeEmit('@setrtpencodingparameters', params, resolve, reject);
              });
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function setRtpEncodingParameters(_x3) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "onTrackEnded",
    value: function onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit('trackended');
      // Emit observer event.
      this._observer.safeEmit('trackended');
    }
  }, {
    key: "handleTrack",
    value: function handleTrack() {
      if (!this._track) return;
      this._track.addEventListener('ended', this.onTrackEnded);
    }
  }, {
    key: "destroyTrack",
    value: function destroyTrack() {
      if (!this._track) return;
      try {
        this._track.removeEventListener('ended', this.onTrackEnded);
        // Just stop the track unless the app set stopTracks: false.
        if (this._stopTracks) this._track.stop();
      } catch (error) {}
    }
  }]);
  return Producer;
}(EnhancedEventEmitter_1.EnhancedEventEmitter);
exports.Producer = Producer;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/RtpParameters.js":
/*!************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/RtpParameters.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/SctpParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/SctpParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Transport.js":
/*!********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Transport.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Transport = void 0;
var awaitqueue_1 = __webpack_require__(/*! awaitqueue */ "./node_modules/awaitqueue/lib/index.js");
var Logger_1 = __webpack_require__(/*! ./Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js");
var utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ./ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var Producer_1 = __webpack_require__(/*! ./Producer */ "./node_modules/mediasoup-client/lib/Producer.js");
var Consumer_1 = __webpack_require__(/*! ./Consumer */ "./node_modules/mediasoup-client/lib/Consumer.js");
var DataProducer_1 = __webpack_require__(/*! ./DataProducer */ "./node_modules/mediasoup-client/lib/DataProducer.js");
var DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ "./node_modules/mediasoup-client/lib/DataConsumer.js");
var logger = new Logger_1.Logger('Transport');
var ConsumerCreationTask = /*#__PURE__*/_createClass(function ConsumerCreationTask(consumerOptions) {
  var _this = this;
  _classCallCheck(this, ConsumerCreationTask);
  this.consumerOptions = consumerOptions;
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
});
var Transport = /*#__PURE__*/function (_EnhancedEventEmitter) {
  _inherits(Transport, _EnhancedEventEmitter);
  var _super = _createSuper(Transport);
  function Transport(_ref) {
    var _this2;
    var direction = _ref.direction,
      id = _ref.id,
      iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      iceServers = _ref.iceServers,
      iceTransportPolicy = _ref.iceTransportPolicy,
      additionalSettings = _ref.additionalSettings,
      proprietaryConstraints = _ref.proprietaryConstraints,
      appData = _ref.appData,
      handlerFactory = _ref.handlerFactory,
      extendedRtpCapabilities = _ref.extendedRtpCapabilities,
      canProduceByKind = _ref.canProduceByKind;
    _classCallCheck(this, Transport);
    _this2 = _super.call(this);
    // Closed flag.
    _this2._closed = false;
    // Transport connection state.
    _this2._connectionState = 'new';
    // Map of Producers indexed by id.
    _this2._producers = new Map();
    // Map of Consumers indexed by id.
    _this2._consumers = new Map();
    // Map of DataProducers indexed by id.
    _this2._dataProducers = new Map();
    // Map of DataConsumers indexed by id.
    _this2._dataConsumers = new Map();
    // Whether the Consumer for RTP probation has been created.
    _this2._probatorConsumerCreated = false;
    // AwaitQueue instance to make async tasks happen sequentially.
    _this2._awaitQueue = new awaitqueue_1.AwaitQueue();
    // Consumer creation tasks awaiting to be processed.
    _this2._pendingConsumerTasks = [];
    // Consumer creation in progress flag.
    _this2._consumerCreationInProgress = false;
    // Consumers pending to be paused.
    _this2._pendingPauseConsumers = new Map();
    // Consumer pause in progress flag.
    _this2._consumerPauseInProgress = false;
    // Consumers pending to be resumed.
    _this2._pendingResumeConsumers = new Map();
    // Consumer resume in progress flag.
    _this2._consumerResumeInProgress = false;
    // Consumers pending to be closed.
    _this2._pendingCloseConsumers = new Map();
    // Consumer close in progress flag.
    _this2._consumerCloseInProgress = false;
    // Observer instance.
    _this2._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
    logger.debug('constructor() [id:%s, direction:%s]', id, direction);
    _this2._id = id;
    _this2._direction = direction;
    _this2._extendedRtpCapabilities = extendedRtpCapabilities;
    _this2._canProduceByKind = canProduceByKind;
    _this2._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
    // Clone and sanitize additionalSettings.
    additionalSettings = utils.clone(additionalSettings, {});
    delete additionalSettings.iceServers;
    delete additionalSettings.iceTransportPolicy;
    delete additionalSettings.bundlePolicy;
    delete additionalSettings.rtcpMuxPolicy;
    delete additionalSettings.sdpSemantics;
    _this2._handler = handlerFactory();
    _this2._handler.run({
      direction: direction,
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      sctpParameters: sctpParameters,
      iceServers: iceServers,
      iceTransportPolicy: iceTransportPolicy,
      additionalSettings: additionalSettings,
      proprietaryConstraints: proprietaryConstraints,
      extendedRtpCapabilities: extendedRtpCapabilities
    });
    _this2._appData = appData || {};
    _this2.handleHandler();
    return _this2;
  }
  /**
   * Transport id.
   */
  _createClass(Transport, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
  }, {
    key: "closed",
    get: function get() {
      return this._closed;
    }
    /**
     * Transport direction.
     */
  }, {
    key: "direction",
    get: function get() {
      return this._direction;
    }
    /**
     * RTC handler instance.
     */
  }, {
    key: "handler",
    get: function get() {
      return this._handler;
    }
    /**
     * Connection state.
     */
  }, {
    key: "connectionState",
    get: function get() {
      return this._connectionState;
    }
    /**
     * App custom data.
     */
  }, {
    key: "appData",
    get: function get() {
      return this._appData;
    }
    /**
     * Invalid setter.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ,

    set: function set(appData) {
      throw new Error('cannot override appData object');
    }
  }, {
    key: "observer",
    get: function get() {
      return this._observer;
    }
    /**
     * Close the Transport.
     */
  }, {
    key: "close",
    value: function close() {
      if (this._closed) return;
      logger.debug('close()');
      this._closed = true;
      // Stop the AwaitQueue.
      this._awaitQueue.stop();
      // Close the handler.
      this._handler.close();
      // Close all Producers.
      var _iterator = _createForOfIteratorHelper(this._producers.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var producer = _step.value;
          producer.transportClosed();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this._producers.clear();
      // Close all Consumers.
      var _iterator2 = _createForOfIteratorHelper(this._consumers.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var consumer = _step2.value;
          consumer.transportClosed();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this._consumers.clear();
      // Close all DataProducers.
      var _iterator3 = _createForOfIteratorHelper(this._dataProducers.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var dataProducer = _step3.value;
          dataProducer.transportClosed();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      this._dataProducers.clear();
      // Close all DataConsumers.
      var _iterator4 = _createForOfIteratorHelper(this._dataConsumers.values()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var dataConsumer = _step4.value;
          dataConsumer.transportClosed();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      this._dataConsumers.clear();
      // Emit observer event.
      this._observer.safeEmit('close');
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
  }, {
    key: "getStats",
    value: function () {
      var _getStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this._closed) {
                _context.next = 2;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 2:
              return _context.abrupt("return", this._handler.getTransportStats());
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getStats() {
        return _getStats.apply(this, arguments);
      }
      return getStats;
    }()
    /**
     * Restart ICE connection.
     */
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref2) {
        var _this3 = this;
        var iceParameters;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              iceParameters = _ref2.iceParameters;
              logger.debug('restartIce()');
              if (!this._closed) {
                _context3.next = 6;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 6:
              if (iceParameters) {
                _context3.next = 8;
                break;
              }
              throw new TypeError('missing iceParameters');
            case 8:
              return _context3.abrupt("return", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      return _context2.abrupt("return", _this3._handler.restartIce(iceParameters));
                    case 1:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              })), 'transport.restartIce()'));
            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function restartIce(_x) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
    /**
     * Update ICE servers.
     */
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this4 = this;
        var _ref4,
          iceServers,
          _args5 = arguments;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _ref4 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, iceServers = _ref4.iceServers;
              logger.debug('updateIceServers()');
              if (!this._closed) {
                _context5.next = 6;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 6:
              if (Array.isArray(iceServers)) {
                _context5.next = 8;
                break;
              }
              throw new TypeError('missing iceServers');
            case 8:
              return _context5.abrupt("return", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                  while (1) switch (_context4.prev = _context4.next) {
                    case 0:
                      return _context4.abrupt("return", _this4._handler.updateIceServers(iceServers));
                    case 1:
                    case "end":
                      return _context4.stop();
                  }
                }, _callee4);
              })), 'transport.updateIceServers()'));
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function updateIceServers() {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
    /**
     * Create a Producer.
     */
  }, {
    key: "produce",
    value: function () {
      var _produce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var _this5 = this;
        var _ref6,
          track,
          encodings,
          codecOptions,
          codec,
          _ref6$stopTracks,
          stopTracks,
          _ref6$disableTrackOnP,
          disableTrackOnPause,
          _ref6$zeroRtpOnPause,
          zeroRtpOnPause,
          _ref6$appData,
          appData,
          _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _ref6 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, track = _ref6.track, encodings = _ref6.encodings, codecOptions = _ref6.codecOptions, codec = _ref6.codec, _ref6$stopTracks = _ref6.stopTracks, stopTracks = _ref6$stopTracks === void 0 ? true : _ref6$stopTracks, _ref6$disableTrackOnP = _ref6.disableTrackOnPause, disableTrackOnPause = _ref6$disableTrackOnP === void 0 ? true : _ref6$disableTrackOnP, _ref6$zeroRtpOnPause = _ref6.zeroRtpOnPause, zeroRtpOnPause = _ref6$zeroRtpOnPause === void 0 ? false : _ref6$zeroRtpOnPause, _ref6$appData = _ref6.appData, appData = _ref6$appData === void 0 ? {} : _ref6$appData;
              logger.debug('produce() [track:%o]', track);
              if (!this._closed) {
                _context7.next = 6;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 6:
              if (track) {
                _context7.next = 10;
                break;
              }
              throw new TypeError('missing track');
            case 10:
              if (!(this._direction !== 'send')) {
                _context7.next = 14;
                break;
              }
              throw new errors_1.UnsupportedError('not a sending Transport');
            case 14:
              if (this._canProduceByKind[track.kind]) {
                _context7.next = 18;
                break;
              }
              throw new errors_1.UnsupportedError("cannot produce ".concat(track.kind));
            case 18:
              if (!(track.readyState === 'ended')) {
                _context7.next = 22;
                break;
              }
              throw new errors_1.InvalidStateError('track ended');
            case 22:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context7.next = 26;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 26:
              if (!(this.listenerCount('produce') === 0)) {
                _context7.next = 30;
                break;
              }
              throw new TypeError('no "produce" listener set into this transport');
            case 30:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context7.next = 32;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 32:
              return _context7.abrupt("return", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
                var normalizedEncodings, _yield$_this5$_handle, localId, rtpParameters, rtpSender, _yield$Promise, id, producer;
                return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                  while (1) switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!(encodings && !Array.isArray(encodings))) {
                        _context6.next = 4;
                        break;
                      }
                      throw TypeError('encodings must be an array');
                    case 4:
                      if (encodings && encodings.length === 0) {
                        normalizedEncodings = undefined;
                      } else if (encodings) {
                        normalizedEncodings = encodings.map(function (encoding) {
                          var normalizedEncoding = {
                            active: true
                          };
                          if (encoding.active === false) normalizedEncoding.active = false;
                          if (typeof encoding.dtx === 'boolean') normalizedEncoding.dtx = encoding.dtx;
                          if (typeof encoding.scalabilityMode === 'string') normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                          if (typeof encoding.scaleResolutionDownBy === 'number') normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                          if (typeof encoding.maxBitrate === 'number') normalizedEncoding.maxBitrate = encoding.maxBitrate;
                          if (typeof encoding.maxFramerate === 'number') normalizedEncoding.maxFramerate = encoding.maxFramerate;
                          if (typeof encoding.adaptivePtime === 'boolean') normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                          if (typeof encoding.priority === 'string') normalizedEncoding.priority = encoding.priority;
                          if (typeof encoding.networkPriority === 'string') normalizedEncoding.networkPriority = encoding.networkPriority;
                          return normalizedEncoding;
                        });
                      }
                    case 5:
                      _context6.next = 7;
                      return _this5._handler.send({
                        track: track,
                        encodings: normalizedEncodings,
                        codecOptions: codecOptions,
                        codec: codec
                      });
                    case 7:
                      _yield$_this5$_handle = _context6.sent;
                      localId = _yield$_this5$_handle.localId;
                      rtpParameters = _yield$_this5$_handle.rtpParameters;
                      rtpSender = _yield$_this5$_handle.rtpSender;
                      _context6.prev = 11;
                      // This will fill rtpParameters's missing fields with default values.
                      ortc.validateRtpParameters(rtpParameters);
                      _context6.next = 15;
                      return new Promise(function (resolve, reject) {
                        _this5.safeEmit('produce', {
                          kind: track.kind,
                          rtpParameters: rtpParameters,
                          appData: appData
                        }, resolve, reject);
                      });
                    case 15:
                      _yield$Promise = _context6.sent;
                      id = _yield$Promise.id;
                      producer = new Producer_1.Producer({
                        id: id,
                        localId: localId,
                        rtpSender: rtpSender,
                        track: track,
                        rtpParameters: rtpParameters,
                        stopTracks: stopTracks,
                        disableTrackOnPause: disableTrackOnPause,
                        zeroRtpOnPause: zeroRtpOnPause,
                        appData: appData
                      });
                      _this5._producers.set(producer.id, producer);
                      _this5.handleProducer(producer);
                      // Emit observer event.
                      _this5._observer.safeEmit('newproducer', producer);
                      return _context6.abrupt("return", producer);
                    case 24:
                      _context6.prev = 24;
                      _context6.t0 = _context6["catch"](11);
                      _this5._handler.stopSending(localId)["catch"](function () {});
                      throw _context6.t0;
                    case 28:
                    case "end":
                      return _context6.stop();
                  }
                }, _callee6, null, [[11, 24]]);
              })), 'transport.produce()')
              // This catch is needed to stop the given track if the command above
              // failed due to closed Transport.
              ["catch"](function (error) {
                if (stopTracks) {
                  try {
                    track.stop();
                  } catch (error2) {}
                }
                throw error;
              }));
            case 33:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function produce() {
        return _produce.apply(this, arguments);
      }
      return produce;
    }()
    /**
     * Create a Consumer to consume a remote Producer.
     */
  }, {
    key: "consume",
    value: function () {
      var _consume = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref8) {
        var id, producerId, kind, rtpParameters, streamId, _ref8$appData, appData, canConsume, consumerCreationTask;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              id = _ref8.id, producerId = _ref8.producerId, kind = _ref8.kind, rtpParameters = _ref8.rtpParameters, streamId = _ref8.streamId, _ref8$appData = _ref8.appData, appData = _ref8$appData === void 0 ? {} : _ref8$appData;
              logger.debug('consume()');
              rtpParameters = utils.clone(rtpParameters, undefined);
              if (!this._closed) {
                _context8.next = 7;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 7:
              if (!(this._direction !== 'recv')) {
                _context8.next = 11;
                break;
              }
              throw new errors_1.UnsupportedError('not a receiving Transport');
            case 11:
              if (!(typeof id !== 'string')) {
                _context8.next = 15;
                break;
              }
              throw new TypeError('missing id');
            case 15:
              if (!(typeof producerId !== 'string')) {
                _context8.next = 19;
                break;
              }
              throw new TypeError('missing producerId');
            case 19:
              if (!(kind !== 'audio' && kind !== 'video')) {
                _context8.next = 23;
                break;
              }
              throw new TypeError("invalid kind '".concat(kind, "'"));
            case 23:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context8.next = 27;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 27:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context8.next = 29;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 29:
              // Ensure the device can consume it.
              canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);
              if (canConsume) {
                _context8.next = 32;
                break;
              }
              throw new errors_1.UnsupportedError('cannot consume this Producer');
            case 32:
              consumerCreationTask = new ConsumerCreationTask({
                id: id,
                producerId: producerId,
                kind: kind,
                rtpParameters: rtpParameters,
                streamId: streamId,
                appData: appData
              }); // Store the Consumer creation task.
              this._pendingConsumerTasks.push(consumerCreationTask);
              // There is no Consumer creation in progress, create it now.
              if (this._consumerCreationInProgress === false) {
                this.createPendingConsumers();
              }
              return _context8.abrupt("return", consumerCreationTask.promise);
            case 36:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function consume(_x2) {
        return _consume.apply(this, arguments);
      }
      return consume;
    }()
    /**
     * Create a DataProducer
     */
  }, {
    key: "produceData",
    value: function () {
      var _produceData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var _this6 = this;
        var _ref9,
          _ref9$ordered,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          _ref9$label,
          label,
          _ref9$protocol,
          protocol,
          _ref9$appData,
          appData,
          _args10 = arguments;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _ref9 = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {}, _ref9$ordered = _ref9.ordered, ordered = _ref9$ordered === void 0 ? true : _ref9$ordered, maxPacketLifeTime = _ref9.maxPacketLifeTime, maxRetransmits = _ref9.maxRetransmits, _ref9$label = _ref9.label, label = _ref9$label === void 0 ? '' : _ref9$label, _ref9$protocol = _ref9.protocol, protocol = _ref9$protocol === void 0 ? '' : _ref9$protocol, _ref9$appData = _ref9.appData, appData = _ref9$appData === void 0 ? {} : _ref9$appData;
              logger.debug('produceData()');
              if (!this._closed) {
                _context10.next = 6;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 6:
              if (!(this._direction !== 'send')) {
                _context10.next = 10;
                break;
              }
              throw new errors_1.UnsupportedError('not a sending Transport');
            case 10:
              if (this._maxSctpMessageSize) {
                _context10.next = 14;
                break;
              }
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
            case 14:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context10.next = 18;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 18:
              if (!(this.listenerCount('producedata') === 0)) {
                _context10.next = 22;
                break;
              }
              throw new TypeError('no "producedata" listener set into this transport');
            case 22:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context10.next = 24;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 24:
              if (maxPacketLifeTime || maxRetransmits) ordered = false;
              // Enqueue command.
              return _context10.abrupt("return", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                var _yield$_this6$_handle, dataChannel, sctpStreamParameters, _yield$Promise2, id, dataProducer;
                return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                  while (1) switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.next = 2;
                      return _this6._handler.sendDataChannel({
                        ordered: ordered,
                        maxPacketLifeTime: maxPacketLifeTime,
                        maxRetransmits: maxRetransmits,
                        label: label,
                        protocol: protocol
                      });
                    case 2:
                      _yield$_this6$_handle = _context9.sent;
                      dataChannel = _yield$_this6$_handle.dataChannel;
                      sctpStreamParameters = _yield$_this6$_handle.sctpStreamParameters;
                      // This will fill sctpStreamParameters's missing fields with default values.
                      ortc.validateSctpStreamParameters(sctpStreamParameters);
                      _context9.next = 8;
                      return new Promise(function (resolve, reject) {
                        _this6.safeEmit('producedata', {
                          sctpStreamParameters: sctpStreamParameters,
                          label: label,
                          protocol: protocol,
                          appData: appData
                        }, resolve, reject);
                      });
                    case 8:
                      _yield$Promise2 = _context9.sent;
                      id = _yield$Promise2.id;
                      dataProducer = new DataProducer_1.DataProducer({
                        id: id,
                        dataChannel: dataChannel,
                        sctpStreamParameters: sctpStreamParameters,
                        appData: appData
                      });
                      _this6._dataProducers.set(dataProducer.id, dataProducer);
                      _this6.handleDataProducer(dataProducer);
                      // Emit observer event.
                      _this6._observer.safeEmit('newdataproducer', dataProducer);
                      return _context9.abrupt("return", dataProducer);
                    case 15:
                    case "end":
                      return _context9.stop();
                  }
                }, _callee9);
              })), 'transport.produceData()'));
            case 26:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function produceData() {
        return _produceData.apply(this, arguments);
      }
      return produceData;
    }()
    /**
     * Create a DataConsumer
     */
  }, {
    key: "consumeData",
    value: function () {
      var _consumeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref11) {
        var _this7 = this;
        var id, dataProducerId, sctpStreamParameters, _ref11$label, label, _ref11$protocol, protocol, _ref11$appData, appData;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              id = _ref11.id, dataProducerId = _ref11.dataProducerId, sctpStreamParameters = _ref11.sctpStreamParameters, _ref11$label = _ref11.label, label = _ref11$label === void 0 ? '' : _ref11$label, _ref11$protocol = _ref11.protocol, protocol = _ref11$protocol === void 0 ? '' : _ref11$protocol, _ref11$appData = _ref11.appData, appData = _ref11$appData === void 0 ? {} : _ref11$appData;
              logger.debug('consumeData()');
              sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);
              if (!this._closed) {
                _context12.next = 7;
                break;
              }
              throw new errors_1.InvalidStateError('closed');
            case 7:
              if (!(this._direction !== 'recv')) {
                _context12.next = 11;
                break;
              }
              throw new errors_1.UnsupportedError('not a receiving Transport');
            case 11:
              if (this._maxSctpMessageSize) {
                _context12.next = 15;
                break;
              }
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
            case 15:
              if (!(typeof id !== 'string')) {
                _context12.next = 19;
                break;
              }
              throw new TypeError('missing id');
            case 19:
              if (!(typeof dataProducerId !== 'string')) {
                _context12.next = 23;
                break;
              }
              throw new TypeError('missing dataProducerId');
            case 23:
              if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {
                _context12.next = 27;
                break;
              }
              throw new TypeError('no "connect" listener set into this transport');
            case 27:
              if (!(appData && _typeof(appData) !== 'object')) {
                _context12.next = 29;
                break;
              }
              throw new TypeError('if given, appData must be an object');
            case 29:
              // This may throw.
              ortc.validateSctpStreamParameters(sctpStreamParameters);
              // Enqueue command.
              return _context12.abrupt("return", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                var _yield$_this7$_handle, dataChannel, dataConsumer;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      _context11.next = 2;
                      return _this7._handler.receiveDataChannel({
                        sctpStreamParameters: sctpStreamParameters,
                        label: label,
                        protocol: protocol
                      });
                    case 2:
                      _yield$_this7$_handle = _context11.sent;
                      dataChannel = _yield$_this7$_handle.dataChannel;
                      dataConsumer = new DataConsumer_1.DataConsumer({
                        id: id,
                        dataProducerId: dataProducerId,
                        dataChannel: dataChannel,
                        sctpStreamParameters: sctpStreamParameters,
                        appData: appData
                      });
                      _this7._dataConsumers.set(dataConsumer.id, dataConsumer);
                      _this7.handleDataConsumer(dataConsumer);
                      // Emit observer event.
                      _this7._observer.safeEmit('newdataconsumer', dataConsumer);
                      return _context11.abrupt("return", dataConsumer);
                    case 9:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee11);
              })), 'transport.consumeData()'));
            case 31:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function consumeData(_x3) {
        return _consumeData.apply(this, arguments);
      }
      return consumeData;
    }() // This method is guaranteed to never throw.
  }, {
    key: "createPendingConsumers",
    value: function () {
      var _createPendingConsumers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var _this8 = this;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              this._consumerCreationInProgress = true;
              this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                var pendingConsumerTasks, videoConsumerForProbator, optionsList, _iterator5, _step5, _task2, _task2$consumerOption, _id, _kind, _rtpParameters, streamId, results, idx, task, result, _task$consumerOptions, id, producerId, kind, rtpParameters, appData, localId, rtpReceiver, track, consumer, _iterator6, _step6, _task, probatorRtpParameters;
                return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                  while (1) switch (_context13.prev = _context13.next) {
                    case 0:
                      if (!(_this8._pendingConsumerTasks.length === 0)) {
                        _context13.next = 3;
                        break;
                      }
                      logger.debug('createPendingConsumers() | there is no Consumer to be created');
                      return _context13.abrupt("return");
                    case 3:
                      pendingConsumerTasks = _toConsumableArray(_this8._pendingConsumerTasks); // Clear pending Consumer tasks.
                      _this8._pendingConsumerTasks = [];
                      // Video Consumer in order to create the probator.
                      videoConsumerForProbator = undefined; // Fill options list.
                      optionsList = [];
                      _iterator5 = _createForOfIteratorHelper(pendingConsumerTasks);
                      try {
                        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                          _task2 = _step5.value;
                          _task2$consumerOption = _task2.consumerOptions, _id = _task2$consumerOption.id, _kind = _task2$consumerOption.kind, _rtpParameters = _task2$consumerOption.rtpParameters, streamId = _task2$consumerOption.streamId;
                          optionsList.push({
                            trackId: _id,
                            kind: _kind,
                            rtpParameters: _rtpParameters,
                            streamId: streamId
                          });
                        }
                      } catch (err) {
                        _iterator5.e(err);
                      } finally {
                        _iterator5.f();
                      }
                      _context13.prev = 9;
                      _context13.next = 12;
                      return _this8._handler.receive(optionsList);
                    case 12:
                      results = _context13.sent;
                      for (idx = 0; idx < results.length; idx++) {
                        task = pendingConsumerTasks[idx];
                        result = results[idx];
                        _task$consumerOptions = task.consumerOptions, id = _task$consumerOptions.id, producerId = _task$consumerOptions.producerId, kind = _task$consumerOptions.kind, rtpParameters = _task$consumerOptions.rtpParameters, appData = _task$consumerOptions.appData;
                        localId = result.localId, rtpReceiver = result.rtpReceiver, track = result.track;
                        consumer = new Consumer_1.Consumer({
                          id: id,
                          localId: localId,
                          producerId: producerId,
                          rtpReceiver: rtpReceiver,
                          track: track,
                          rtpParameters: rtpParameters,
                          appData: appData
                        });
                        _this8._consumers.set(consumer.id, consumer);
                        _this8.handleConsumer(consumer);
                        // If this is the first video Consumer and the Consumer for RTP probation
                        // has not yet been created, it's time to create it.
                        if (!_this8._probatorConsumerCreated && !videoConsumerForProbator && kind === 'video') {
                          videoConsumerForProbator = consumer;
                        }
                        // Emit observer event.
                        _this8._observer.safeEmit('newconsumer', consumer);
                        task.resolve(consumer);
                      }
                      _context13.next = 20;
                      break;
                    case 16:
                      _context13.prev = 16;
                      _context13.t0 = _context13["catch"](9);
                      _iterator6 = _createForOfIteratorHelper(pendingConsumerTasks);
                      try {
                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                          _task = _step6.value;
                          _task.reject(_context13.t0);
                        }
                      } catch (err) {
                        _iterator6.e(err);
                      } finally {
                        _iterator6.f();
                      }
                    case 20:
                      if (!videoConsumerForProbator) {
                        _context13.next = 32;
                        break;
                      }
                      _context13.prev = 21;
                      probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                      _context13.next = 25;
                      return _this8._handler.receive([{
                        trackId: 'probator',
                        kind: 'video',
                        rtpParameters: probatorRtpParameters
                      }]);
                    case 25:
                      logger.debug('createPendingConsumers() | Consumer for RTP probation created');
                      _this8._probatorConsumerCreated = true;
                      _context13.next = 32;
                      break;
                    case 29:
                      _context13.prev = 29;
                      _context13.t1 = _context13["catch"](21);
                      logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', _context13.t1);
                    case 32:
                    case "end":
                      return _context13.stop();
                  }
                }, _callee13, null, [[9, 16], [21, 29]]);
              })), 'transport.createPendingConsumers()').then(function () {
                _this8._consumerCreationInProgress = false;
                // There are pending Consumer tasks, enqueue their creation.
                if (_this8._pendingConsumerTasks.length > 0) {
                  _this8.createPendingConsumers();
                }
              })
              // NOTE: We only get here when the await queue is closed.
              ["catch"](function () {});
            case 2:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function createPendingConsumers() {
        return _createPendingConsumers.apply(this, arguments);
      }
      return createPendingConsumers;
    }()
  }, {
    key: "pausePendingConsumers",
    value: function pausePendingConsumers() {
      var _this9 = this;
      this._consumerPauseInProgress = true;
      this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var pendingPauseConsumers, localIds;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              if (!(_this9._pendingPauseConsumers.size === 0)) {
                _context15.next = 3;
                break;
              }
              logger.debug('pausePendingConsumers() | there is no Consumer to be paused');
              return _context15.abrupt("return");
            case 3:
              pendingPauseConsumers = Array.from(_this9._pendingPauseConsumers.values()); // Clear pending pause Consumer map.
              _this9._pendingPauseConsumers.clear();
              _context15.prev = 5;
              localIds = pendingPauseConsumers.map(function (consumer) {
                return consumer.localId;
              });
              _context15.next = 9;
              return _this9._handler.pauseReceiving(localIds);
            case 9:
              _context15.next = 14;
              break;
            case 11:
              _context15.prev = 11;
              _context15.t0 = _context15["catch"](5);
              logger.error('pausePendingConsumers() | failed to pause Consumers:', _context15.t0);
            case 14:
            case "end":
              return _context15.stop();
          }
        }, _callee15, null, [[5, 11]]);
      })), 'transport.pausePendingConsumers').then(function () {
        _this9._consumerPauseInProgress = false;
        // There are pending Consumers to be paused, do it.
        if (_this9._pendingPauseConsumers.size > 0) {
          _this9.pausePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "resumePendingConsumers",
    value: function resumePendingConsumers() {
      var _this10 = this;
      this._consumerResumeInProgress = true;
      this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var pendingResumeConsumers, localIds;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              if (!(_this10._pendingResumeConsumers.size === 0)) {
                _context16.next = 3;
                break;
              }
              logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');
              return _context16.abrupt("return");
            case 3:
              pendingResumeConsumers = Array.from(_this10._pendingResumeConsumers.values()); // Clear pending resume Consumer map.
              _this10._pendingResumeConsumers.clear();
              _context16.prev = 5;
              localIds = pendingResumeConsumers.map(function (consumer) {
                return consumer.localId;
              });
              _context16.next = 9;
              return _this10._handler.resumeReceiving(localIds);
            case 9:
              _context16.next = 14;
              break;
            case 11:
              _context16.prev = 11;
              _context16.t0 = _context16["catch"](5);
              logger.error('resumePendingConsumers() | failed to resume Consumers:', _context16.t0);
            case 14:
            case "end":
              return _context16.stop();
          }
        }, _callee16, null, [[5, 11]]);
      })), 'transport.resumePendingConsumers').then(function () {
        _this10._consumerResumeInProgress = false;
        // There are pending Consumer to be resumed, do it.
        if (_this10._pendingResumeConsumers.size > 0) {
          _this10.resumePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "closePendingConsumers",
    value: function closePendingConsumers() {
      var _this11 = this;
      this._consumerCloseInProgress = true;
      this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var pendingCloseConsumers;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              if (!(_this11._pendingCloseConsumers.size === 0)) {
                _context17.next = 3;
                break;
              }
              logger.debug('closePendingConsumers() | there is no Consumer to be closed');
              return _context17.abrupt("return");
            case 3:
              pendingCloseConsumers = Array.from(_this11._pendingCloseConsumers.values()); // Clear pending close Consumer map.
              _this11._pendingCloseConsumers.clear();
              _context17.prev = 5;
              _context17.next = 8;
              return _this11._handler.stopReceiving(pendingCloseConsumers.map(function (consumer) {
                return consumer.localId;
              }));
            case 8:
              _context17.next = 13;
              break;
            case 10:
              _context17.prev = 10;
              _context17.t0 = _context17["catch"](5);
              logger.error('closePendingConsumers() | failed to close Consumers:', _context17.t0);
            case 13:
            case "end":
              return _context17.stop();
          }
        }, _callee17, null, [[5, 10]]);
      })), 'transport.closePendingConsumers').then(function () {
        _this11._consumerCloseInProgress = false;
        // There are pending Consumer to be resumed, do it.
        if (_this11._pendingCloseConsumers.size > 0) {
          _this11.closePendingConsumers();
        }
      })
      // NOTE: We only get here when the await queue is closed.
      ["catch"](function () {});
    }
  }, {
    key: "handleHandler",
    value: function handleHandler() {
      var _this12 = this;
      var handler = this._handler;
      handler.on('@connect', function (_ref17, callback, errback) {
        var dtlsParameters = _ref17.dtlsParameters;
        if (_this12._closed) {
          errback(new errors_1.InvalidStateError('closed'));
          return;
        }
        _this12.safeEmit('connect', {
          dtlsParameters: dtlsParameters
        }, callback, errback);
      });
      handler.on('@connectionstatechange', function (connectionState) {
        if (connectionState === _this12._connectionState) return;
        logger.debug('connection state changed to %s', connectionState);
        _this12._connectionState = connectionState;
        if (!_this12._closed) _this12.safeEmit('connectionstatechange', connectionState);
      });
    }
  }, {
    key: "handleProducer",
    value: function handleProducer(producer) {
      var _this13 = this;
      producer.on('@close', function () {
        _this13._producers["delete"](producer.id);
        if (_this13._closed) return;
        _this13._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", _this13._handler.stopSending(producer.localId));
              case 1:
              case "end":
                return _context18.stop();
            }
          }, _callee18);
        })), 'producer @close event')["catch"](function (error) {
          return logger.warn('producer.close() failed:%o', error);
        });
      });
      producer.on('@pause', function (callback, errback) {
        _this13._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                return _context19.abrupt("return", _this13._handler.pauseSending(producer.localId));
              case 1:
              case "end":
                return _context19.stop();
            }
          }, _callee19);
        })), 'producer @pause event').then(callback)["catch"](errback);
      });
      producer.on('@resume', function (callback, errback) {
        _this13._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", _this13._handler.resumeSending(producer.localId));
              case 1:
              case "end":
                return _context20.stop();
            }
          }, _callee20);
        })), 'producer @resume event').then(callback)["catch"](errback);
      });
      producer.on('@replacetrack', function (track, callback, errback) {
        _this13._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                return _context21.abrupt("return", _this13._handler.replaceTrack(producer.localId, track));
              case 1:
              case "end":
                return _context21.stop();
            }
          }, _callee21);
        })), 'producer @replacetrack event').then(callback)["catch"](errback);
      });
      producer.on('@setmaxspatiallayer', function (spatialLayer, callback, errback) {
        _this13._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                return _context22.abrupt("return", _this13._handler.setMaxSpatialLayer(producer.localId, spatialLayer));
              case 1:
              case "end":
                return _context22.stop();
            }
          }, _callee22);
        })), 'producer @setmaxspatiallayer event').then(callback)["catch"](errback);
      });
      producer.on('@setrtpencodingparameters', function (params, callback, errback) {
        _this13._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                return _context23.abrupt("return", _this13._handler.setRtpEncodingParameters(producer.localId, params));
              case 1:
              case "end":
                return _context23.stop();
            }
          }, _callee23);
        })), 'producer @setrtpencodingparameters event').then(callback)["catch"](errback);
      });
      producer.on('@getstats', function (callback, errback) {
        if (_this13._closed) return errback(new errors_1.InvalidStateError('closed'));
        _this13._handler.getSenderStats(producer.localId).then(callback)["catch"](errback);
      });
    }
  }, {
    key: "handleConsumer",
    value: function handleConsumer(consumer) {
      var _this14 = this;
      consumer.on('@close', function () {
        _this14._consumers["delete"](consumer.id);
        _this14._pendingPauseConsumers["delete"](consumer.id);
        _this14._pendingResumeConsumers["delete"](consumer.id);
        if (_this14._closed) return;
        // Store the Consumer into the close list.
        _this14._pendingCloseConsumers.set(consumer.id, consumer);
        // There is no Consumer close in progress, do it now.
        if (_this14._consumerCloseInProgress === false) {
          _this14.closePendingConsumers();
        }
      });
      consumer.on('@pause', function () {
        // If Consumer is pending to be resumed, remove from pending resume list.
        if (_this14._pendingResumeConsumers.has(consumer.id)) {
          _this14._pendingResumeConsumers["delete"](consumer.id);
        }
        // Store the Consumer into the pending list.
        _this14._pendingPauseConsumers.set(consumer.id, consumer);
        // There is no Consumer pause in progress, do it now.
        if (_this14._consumerPauseInProgress === false) {
          _this14.pausePendingConsumers();
        }
      });
      consumer.on('@resume', function () {
        // If Consumer is pending to be paused, remove from pending pause list.
        if (_this14._pendingPauseConsumers.has(consumer.id)) {
          _this14._pendingPauseConsumers["delete"](consumer.id);
        }
        // Store the Consumer into the pending list.
        _this14._pendingResumeConsumers.set(consumer.id, consumer);
        // There is no Consumer resume in progress, do it now.
        if (_this14._consumerResumeInProgress === false) {
          _this14.resumePendingConsumers();
        }
      });
      consumer.on('@getstats', function (callback, errback) {
        if (_this14._closed) return errback(new errors_1.InvalidStateError('closed'));
        _this14._handler.getReceiverStats(consumer.localId).then(callback)["catch"](errback);
      });
    }
  }, {
    key: "handleDataProducer",
    value: function handleDataProducer(dataProducer) {
      var _this15 = this;
      dataProducer.on('@close', function () {
        _this15._dataProducers["delete"](dataProducer.id);
      });
    }
  }, {
    key: "handleDataConsumer",
    value: function handleDataConsumer(dataConsumer) {
      var _this16 = this;
      dataConsumer.on('@close', function () {
        _this16._dataConsumers["delete"](dataConsumer.id);
      });
    }
  }]);
  return Transport;
}(EnhancedEventEmitter_1.EnhancedEventEmitter);
exports.Transport = Transport;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
var UnsupportedError = /*#__PURE__*/function (_Error) {
  _inherits(UnsupportedError, _Error);
  var _super = _createSuper(UnsupportedError);
  function UnsupportedError(message) {
    var _this;
    _classCallCheck(this, UnsupportedError);
    _this = _super.call(this, message);
    _this.name = 'UnsupportedError';
    if (Error.hasOwnProperty('captureStackTrace'))
      // Just in V8.
      {
        // @ts-ignore
        Error.captureStackTrace(_assertThisInitialized(_this), UnsupportedError);
      } else {
      _this.stack = new Error(message).stack;
    }
    return _this;
  }
  return _createClass(UnsupportedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
var InvalidStateError = /*#__PURE__*/function (_Error2) {
  _inherits(InvalidStateError, _Error2);
  var _super2 = _createSuper(InvalidStateError);
  function InvalidStateError(message) {
    var _this2;
    _classCallCheck(this, InvalidStateError);
    _this2 = _super2.call(this, message);
    _this2.name = 'InvalidStateError';
    if (Error.hasOwnProperty('captureStackTrace'))
      // Just in V8.
      {
        // @ts-ignore
        Error.captureStackTrace(_assertThisInitialized(_this2), InvalidStateError);
      } else {
      _this2.stack = new Error(message).stack;
    }
    return _this2;
  }
  return _createClass(InvalidStateError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.InvalidStateError = InvalidStateError;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome55.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome55.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Chrome55 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var logger = new Logger_1.Logger('Chrome55');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome55 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Chrome55, _HandlerInterface_1$H);
  var _super = _createSuper(Chrome55);
  function Chrome55() {
    var _this;
    _classCallCheck(this, Chrome55);
    _this = _super.call(this);
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Map of sending MediaStreamTracks indexed by localId.
    _this._mapSendLocalIdTrack = new Map();
    // Next sending localId.
    _this._nextSendLocalId = 0;
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _this._mapRecvLocalIdInfo = new Map();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Chrome55, [{
    key: "name",
    get: function get() {
      return 'Chrome55';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.prev = 2;
              _context.next = 5;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 5:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 12]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'plan-b'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addStream(this._sendStream);
              _context6.next = 8;
              return this._pc.createOffer();
            case 8:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.next = 17;
                break;
              }
              _context6.next = 17;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 21;
              return this._pc.setLocalDescription(offer);
            case 21:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) _extends(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
              }
              // If VP8 and there is effective simulcast, add scalabilityMode to each
              // encoding.
              if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 32;
              return this._pc.setRemoteDescription(answer);
            case 32:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              // Insert into the map.
              this._mapSendLocalIdTrack.set(localId, track);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters
              });
            case 36:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var track, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              track = this._mapSendLocalIdTrack.get(localId);
              if (track) {
                _context7.next = 5;
                break;
              }
              throw new Error('track not found');
            case 5:
              this._mapSendLocalIdTrack["delete"](localId);
              this._sendStream.removeTrack(track);
              this._pc.addStream(this._sendStream);
              _context7.next = 10;
              return this._pc.createOffer();
            case 10:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.prev = 12;
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              _context7.next = 23;
              break;
            case 17:
              _context7.prev = 17;
              _context7.t0 = _context7["catch"](12);
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.next = 22;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());
              return _context7.abrupt("return");
            case 22:
              throw _context7.t0;
            case 23:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.next = 25;
                break;
              }
              return _context7.abrupt("return");
            case 25:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 29;
              return this._pc.setRemoteDescription(answer);
            case 29:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[12, 17]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId, track) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              throw new errors_1.UnsupportedError(' not implemented');
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              throw new errors_1.UnsupportedError('not supported');
            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, mid, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 8;
              return this._pc.setRemoteDescription(offer);
            case 8:
              _context17.next = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 13;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 16:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 20;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 18);
            case 18:
              _context17.next = 16;
              break;
            case 20:
              _context17.next = 25;
              break;
            case 22:
              _context17.prev = 22;
              _context17.t1 = _context17["catch"](13);
              _iterator3.e(_context17.t1);
            case 25:
              _context17.prev = 25;
              _iterator3.f();
              return _context17.finish(25);
            case 28:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 32;
                break;
              }
              _context17.next = 32;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 32:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 35;
              return this._pc.setLocalDescription(answer);
            case 35:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 36;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, kind, trackId, rtpParameters, mid, localId, streamId, stream, track;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      mid = kind;
                      localId = trackId;
                      streamId = options.streamId || rtpParameters.rtcp.cname;
                      stream = _this3._pc.getRemoteStreams().find(function (s) {
                        return s.id === streamId;
                      });
                      track = stream.getTrackById(localId);
                      if (track) {
                        _context16.next = 9;
                        break;
                      }
                      throw new Error('remote track not found');
                    case 9:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters
                      });
                      results.push({
                        localId: localId,
                        track: track
                      });
                    case 11:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 39:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 43;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 41);
            case 41:
              _context17.next = 39;
              break;
            case 43:
              _context17.next = 48;
              break;
            case 45:
              _context17.prev = 45;
              _context17.t3 = _context17["catch"](36);
              _iterator4.e(_context17.t3);
            case 48:
              _context17.prev = 48;
              _iterator4.f();
              return _context17.finish(48);
            case 51:
              return _context17.abrupt("return", results);
            case 52:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[13, 22, 25, 28], [36, 45, 48, 51]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 7;
              return this._pc.setRemoteDescription(offer);
            case 7:
              _context18.next = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 13;
              return this._pc.setLocalDescription(answer);
            case 13:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
            case "end":
              return _context19.stop();
          }
        }, _callee17);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
            case "end":
              return _context20.stop();
          }
        }, _callee18);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context21.stop();
          }
        }, _callee19);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref5) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref6) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome55();
      };
    }
  }]);
  return Chrome55;
}(HandlerInterface_1.HandlerInterface);
exports.Chrome55 = Chrome55;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome67.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome67.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Chrome67 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var logger = new Logger_1.Logger('Chrome67');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome67 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Chrome67, _HandlerInterface_1$H);
  var _super = _createSuper(Chrome67);
  function Chrome67() {
    var _this;
    _classCallCheck(this, Chrome67);
    _this = _super.call(this);
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Map of RTCRtpSender indexed by localId.
    _this._mapSendLocalIdRtpSender = new Map();
    // Next sending localId.
    _this._nextSendLocalId = 0;
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _this._mapRecvLocalIdInfo = new Map();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Chrome67, [{
    key: "name",
    get: function get() {
      return 'Chrome67';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.prev = 2;
              _context.next = 5;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 5:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 12]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'plan-b'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId, rtpSender;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addTrack(track, this._sendStream);
              _context6.next = 8;
              return this._pc.createOffer();
            case 8:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.next = 17;
                break;
              }
              _context6.next = 17;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 21;
              return this._pc.setLocalDescription(offer);
            case 21:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) _extends(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
              }
              // If VP8 and there is effective simulcast, add scalabilityMode to each
              // encoding.
              if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 32;
              return this._pc.setRemoteDescription(answer);
            case 32:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              rtpSender = this._pc.getSenders().find(function (s) {
                return s.track === track;
              }); // Insert into the map.
              this._mapSendLocalIdRtpSender.set(localId, rtpSender);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: rtpSender
              });
            case 37:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var rtpSender, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context7.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              this._pc.removeTrack(rtpSender);
              if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);
              this._mapSendLocalIdRtpSender["delete"](localId);
              _context7.next = 10;
              return this._pc.createOffer();
            case 10:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.prev = 12;
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              _context7.next = 23;
              break;
            case 17:
              _context7.prev = 17;
              _context7.t0 = _context7["catch"](12);
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.next = 22;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());
              return _context7.abrupt("return");
            case 22:
              throw _context7.t0;
            case 23:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.next = 25;
                break;
              }
              return _context7.abrupt("return");
            case 25:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 29;
              return this._pc.setRemoteDescription(answer);
            case 29:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[12, 17]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var rtpSender, oldTrack;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              oldTrack = rtpSender.track;
              _context10.next = 8;
              return rtpSender.replaceTrack(track);
            case 8:
              // Remove the old track from the local stream.
              if (oldTrack) this._sendStream.removeTrack(oldTrack);
              // Add the new track to the local stream.
              if (track) this._sendStream.addTrack(track);
            case 10:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var rtpSender, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 9;
              return rtpSender.setParameters(parameters);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var rtpSender, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return rtpSender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var rtpSender;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 4:
              return _context13.abrupt("return", rtpSender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, mid, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 8;
              return this._pc.setRemoteDescription(offer);
            case 8:
              _context17.next = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 13;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 16:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 20;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 18);
            case 18:
              _context17.next = 16;
              break;
            case 20:
              _context17.next = 25;
              break;
            case 22:
              _context17.prev = 22;
              _context17.t1 = _context17["catch"](13);
              _iterator3.e(_context17.t1);
            case 25:
              _context17.prev = 25;
              _iterator3.f();
              return _context17.finish(25);
            case 28:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 32;
                break;
              }
              _context17.next = 32;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 32:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 35;
              return this._pc.setLocalDescription(answer);
            case 35:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 36;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, kind, trackId, rtpParameters, localId, mid, rtpReceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = trackId;
                      mid = kind;
                      rtpReceiver = _this3._pc.getReceivers().find(function (r) {
                        return r.track && r.track.id === localId;
                      });
                      if (rtpReceiver) {
                        _context16.next = 7;
                        break;
                      }
                      throw new Error('new RTCRtpReceiver not');
                    case 7:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters,
                        rtpReceiver: rtpReceiver
                      });
                      results.push({
                        localId: localId,
                        track: rtpReceiver.track,
                        rtpReceiver: rtpReceiver
                      });
                    case 9:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 39:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 43;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 41);
            case 41:
              _context17.next = 39;
              break;
            case 43:
              _context17.next = 48;
              break;
            case 45:
              _context17.prev = 45;
              _context17.t3 = _context17["catch"](36);
              _iterator4.e(_context17.t3);
            case 48:
              _context17.prev = 48;
              _iterator4.f();
              return _context17.finish(48);
            case 51:
              return _context17.abrupt("return", results);
            case 52:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[13, 22, 25, 28], [36, 45, 48, 51]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 7;
              return this._pc.setRemoteDescription(offer);
            case 7:
              _context18.next = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 13;
              return this._pc.setLocalDescription(answer);
            case 13:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
            case "end":
              return _context19.stop();
          }
        }, _callee17);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
            case "end":
              return _context20.stop();
          }
        }, _callee18);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var _ref5, rtpReceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.assertRecvDirection();
              _ref5 = this._mapRecvLocalIdInfo.get(localId) || {}, rtpReceiver = _ref5.rtpReceiver;
              if (rtpReceiver) {
                _context21.next = 4;
                break;
              }
              throw new Error('associated RTCRtpReceiver not found');
            case 4:
              return _context21.abrupt("return", rtpReceiver.getStats());
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref6) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref6.sctpStreamParameters, label = _ref6.label, protocol = _ref6.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref7) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref7.localDtlsRole, localSdpObject = _ref7.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome67();
      };
    }
  }]);
  return Chrome67;
}(HandlerInterface_1.HandlerInterface);
exports.Chrome67 = Chrome67;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome70.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome70.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Chrome70 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
var logger = new Logger_1.Logger('Chrome70');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome70 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Chrome70, _HandlerInterface_1$H);
  var _super = _createSuper(Chrome70);
  function Chrome70() {
    var _this;
    _classCallCheck(this, Chrome70);
    _this = _super.call(this);
    // Map of RTCTransceivers indexed by MID.
    _this._mapMidTransceiver = new Map();
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Chrome70, [{
    key: "name",
    get: function get() {
      return 'Chrome70';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.prev = 2;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.next = 7;
              return pc.createOffer();
            case 7:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 14]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, hackVp9Svc, layers, parameters, idx, encoding, desiredEncoding, localId, _idx, _iterator, _step, _encoding, answer;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              });
              _context6.next = 11;
              return this._pc.createOffer();
            case 11:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (this._transportReady) {
                _context6.next = 16;
                break;
              }
              _context6.next = 16;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 16:
              if (encodings && encodings.length > 1) {
                logger.debug('send() | enabling legacy simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 23;
              return this._pc.setLocalDescription(offer);
            case 23:
              if (!encodings) {
                _context6.next = 38;
                break;
              }
              logger.debug('send() | applying given encodings');
              parameters = transceiver.sender.getParameters();
              idx = 0;
            case 27:
              if (!(idx < (parameters.encodings || []).length)) {
                _context6.next = 36;
                break;
              }
              encoding = parameters.encodings[idx];
              desiredEncoding = encodings[idx]; // Should not happen but just in case.
              if (desiredEncoding) {
                _context6.next = 32;
                break;
              }
              return _context6.abrupt("break", 36);
            case 32:
              parameters.encodings[idx] = _extends(encoding, desiredEncoding);
            case 33:
              ++idx;
              _context6.next = 27;
              break;
            case 36:
              _context6.next = 38;
              return transceiver.sender.setParameters(parameters);
            case 38:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject
              });
              // Complete encodings with given values.
              if (encodings) {
                for (_idx = 0; _idx < sendingRtpParameters.encodings.length; ++_idx) {
                  if (encodings[_idx]) _extends(sendingRtpParameters.encodings[_idx], encodings[_idx]);
                }
              }
              // Hack for VP9 SVC.
              if (hackVp9Svc) {
                sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _encoding = _step.value;
                    _encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 52;
              return this._pc.setRemoteDescription(answer);
            case 52:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
            case 54:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.next = 11;
              return this._pc.createOffer();
            case 11:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 19;
              return this._pc.setRemoteDescription(answer);
            case 19:
              this._mapMidTransceiver["delete"](localId);
            case 20:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              _context10.next = 7;
              return transceiver.sender.replaceTrack(track);
            case 7:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context13.abrupt("return", transceiver.sender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, mapLocalId, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.next = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 14;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 17:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 21;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 19);
            case 19:
              _context17.next = 17;
              break;
            case 21:
              _context17.next = 26;
              break;
            case 23:
              _context17.prev = 23;
              _context17.t1 = _context17["catch"](14);
              _iterator3.e(_context17.t1);
            case 26:
              _context17.prev = 26;
              _iterator3.f();
              return _context17.finish(26);
            case 29:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 33;
                break;
              }
              _context17.next = 33;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 33:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 36;
              return this._pc.setLocalDescription(answer);
            case 36:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 37;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context16.next = 6;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 6:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 8:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 40:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 44;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 42);
            case 42:
              _context17.next = 40;
              break;
            case 44:
              _context17.next = 49;
              break;
            case 46:
              _context17.prev = 46;
              _context17.t3 = _context17["catch"](37);
              _iterator4.e(_context17.t3);
            case 49:
              _context17.prev = 49;
              _iterator4.f();
              return _context17.finish(49);
            case 52:
              return _context17.abrupt("return", results);
            case 53:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[14, 23, 26, 29], [37, 46, 49, 52]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context18.prev = 2;
              _iterator5.s();
            case 4:
              if ((_step5 = _iterator5.n()).done) {
                _context18.next = 13;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 11:
              _context18.next = 4;
              break;
            case 13:
              _context18.next = 18;
              break;
            case 15:
              _context18.prev = 15;
              _context18.t0 = _context18["catch"](2);
              _iterator5.e(_context18.t0);
            case 18:
              _context18.prev = 18;
              _iterator5.f();
              return _context18.finish(18);
            case 21:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 25;
              return this._pc.setRemoteDescription(offer);
            case 25:
              _context18.next = 27;
              return this._pc.createAnswer();
            case 27:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 31;
              return this._pc.setLocalDescription(answer);
            case 31:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 33:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this, [[2, 15, 18, 21]]);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
            case "end":
              return _context19.stop();
          }
        }, _callee17);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
            case "end":
              return _context20.stop();
          }
        }, _callee18);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context21.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context21.abrupt("return", transceiver.receiver.getStats());
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref4) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome70();
      };
    }
  }]);
  return Chrome70;
}(HandlerInterface_1.HandlerInterface);
exports.Chrome70 = Chrome70;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome74.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome74.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Chrome74 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
var logger = new Logger_1.Logger('Chrome74');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Chrome74 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Chrome74, _HandlerInterface_1$H);
  var _super = _createSuper(Chrome74);
  function Chrome74() {
    var _this;
    _classCallCheck(this, Chrome74);
    _this = _super.call(this);
    // Map of RTCTransceivers indexed by MID.
    _this._mapMidTransceiver = new Map();
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Chrome74, [{
    key: "name",
    get: function get() {
      return 'Chrome74';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.prev = 2;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.next = 7;
              return pc.createOffer();
            case 7:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 14]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
        this._pc.addEventListener('iceconnectionstatechange', function () {
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, hackVp9Svc, layers, localId, newEncodings, _iterator, _step, encoding, answer;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              _context6.next = 12;
              return this._pc.createOffer();
            case 12:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (this._transportReady) {
                _context6.next = 17;
                break;
              }
              _context6.next = 17;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 23;
              return this._pc.setLocalDescription(offer);
            case 23:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                _extends(newEncodings[0], encodings[0]);
                // Hack for VP9 SVC.
                if (hackVp9Svc) newEncodings = [newEncodings[0]];
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions,
                extmapAllowMixed: true
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 35;
              return this._pc.setRemoteDescription(answer);
            case 35:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
            case 37:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.next = 11;
              return this._pc.createOffer();
            case 11:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 19;
              return this._pc.setRemoteDescription(answer);
            case 19:
              this._mapMidTransceiver["delete"](localId);
            case 20:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context8.sent;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context9.next = 6;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 6:
              transceiver.direction = 'sendonly';
              _context9.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context9.sent;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              _context10.next = 7;
              return transceiver.sender.replaceTrack(track);
            case 7:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context13.abrupt("return", transceiver.sender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, mapLocalId, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.next = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 14;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 17:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 21;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 19);
            case 19:
              _context17.next = 17;
              break;
            case 21:
              _context17.next = 26;
              break;
            case 23:
              _context17.prev = 23;
              _context17.t1 = _context17["catch"](14);
              _iterator3.e(_context17.t1);
            case 26:
              _context17.prev = 26;
              _iterator3.f();
              return _context17.finish(26);
            case 29:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 33;
                break;
              }
              _context17.next = 33;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 33:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 36;
              return this._pc.setLocalDescription(answer);
            case 36:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 37;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context16.next = 8;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 8:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 10:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 40:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 44;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 42);
            case 42:
              _context17.next = 40;
              break;
            case 44:
              _context17.next = 49;
              break;
            case 46:
              _context17.prev = 46;
              _context17.t3 = _context17["catch"](37);
              _iterator4.e(_context17.t3);
            case 49:
              _context17.prev = 49;
              _iterator4.f();
              return _context17.finish(49);
            case 52:
              return _context17.abrupt("return", results);
            case 53:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[14, 23, 26, 29], [37, 46, 49, 52]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context18.prev = 2;
              _iterator5.s();
            case 4:
              if ((_step5 = _iterator5.n()).done) {
                _context18.next = 13;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 11:
              _context18.next = 4;
              break;
            case 13:
              _context18.next = 18;
              break;
            case 15:
              _context18.prev = 15;
              _context18.t0 = _context18["catch"](2);
              _iterator5.e(_context18.t0);
            case 18:
              _context18.prev = 18;
              _iterator5.f();
              return _context18.finish(18);
            case 21:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 25;
              return this._pc.setRemoteDescription(offer);
            case 25:
              _context18.next = 27;
              return this._pc.createAnswer();
            case 27:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 31;
              return this._pc.setLocalDescription(answer);
            case 31:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 33:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this, [[2, 15, 18, 21]]);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context19.prev = 2;
              _iterator7.s();
            case 4:
              if ((_step7 = _iterator7.n()).done) {
                _context19.next = 14;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 12:
              _context19.next = 4;
              break;
            case 14:
              _context19.next = 19;
              break;
            case 16:
              _context19.prev = 16;
              _context19.t0 = _context19["catch"](2);
              _iterator7.e(_context19.t0);
            case 19:
              _context19.prev = 19;
              _iterator7.f();
              return _context19.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context19.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context19.sent;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context19.stop();
          }
        }, _callee17, this, [[2, 16, 19, 22]]);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context20.prev = 2;
              _iterator8.s();
            case 4:
              if ((_step8 = _iterator8.n()).done) {
                _context20.next = 14;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 12:
              _context20.next = 4;
              break;
            case 14:
              _context20.next = 19;
              break;
            case 16:
              _context20.prev = 16;
              _context20.t0 = _context20["catch"](2);
              _iterator8.e(_context20.t0);
            case 19:
              _context20.prev = 19;
              _iterator8.f();
              return _context20.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context20.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context20.sent;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context20.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context20.stop();
          }
        }, _callee18, this, [[2, 16, 19, 22]]);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context21.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context21.abrupt("return", transceiver.receiver.getStats());
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref4) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Chrome74();
      };
    }
  }]);
  return Chrome74;
}(HandlerInterface_1.HandlerInterface);
exports.Chrome74 = Chrome74;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Edge11.js":
/*!**************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Edge11.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Edge11 = void 0;
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var edgeUtils = __importStar(__webpack_require__(/*! ./ortc/edgeUtils */ "./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var logger = new Logger_1.Logger('Edge11');
var Edge11 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Edge11, _HandlerInterface_1$H);
  var _super = _createSuper(Edge11);
  function Edge11() {
    var _this;
    _classCallCheck(this, Edge11);
    _this = _super.call(this);
    // Map of RTCRtpSenders indexed by id.
    _this._rtpSenders = new Map();
    // Map of RTCRtpReceivers indexed by id.
    _this._rtpReceivers = new Map();
    // Next localId for sending tracks.
    _this._nextSendLocalId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Edge11, [{
    key: "name",
    get: function get() {
      return 'Edge11';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close the ICE gatherer.
      // NOTE: Not yet implemented by Edge.
      try {
        this._iceGatherer.close();
      } catch (error) {}
      // Close the ICE transport.
      try {
        this._iceTransport.stop();
      } catch (error) {}
      // Close the DTLS transport.
      try {
        this._dtlsTransport.stop();
      } catch (error) {}
      // Close RTCRtpSenders.
      var _iterator = _createForOfIteratorHelper(this._rtpSenders.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var rtpSender = _step.value;
          try {
            rtpSender.stop();
          } catch (error) {}
        }
        // Close RTCRtpReceivers.
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(this._rtpReceivers.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rtpReceiver = _step2.value;
          try {
            rtpReceiver.stop();
          } catch (error) {}
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              return _context.abrupt("return", edgeUtils.getCapabilities());
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: {
                  OS: 0,
                  MIS: 0
                }
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._remoteIceParameters = iceParameters;
      this._remoteIceCandidates = iceCandidates;
      this._remoteDtlsParameters = dtlsParameters;
      this._cname = "CNAME-".concat(utils.generateRandomNumber());
      this.setIceGatherer({
        iceServers: iceServers,
        iceTransportPolicy: iceTransportPolicy
      });
      this.setIceTransport();
      this.setDtlsTransport();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              throw new errors_1.UnsupportedError('not supported');
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var _iterator3, _step3, candidate;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              this._remoteIceParameters = iceParameters;
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              logger.debug('restartIce() | calling iceTransport.start()');
              this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');
              _iterator3 = _createForOfIteratorHelper(this._remoteIceCandidates);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  candidate = _step3.value;
                  this._iceTransport.addRemoteCandidate(candidate);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              this._iceTransport.addRemoteCandidate({});
            case 9:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._iceTransport.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _ref2) {
        var track, encodings, codecOptions, codec, rtpSender, rtpParameters, useRtx, _iterator4, _step4, encoding, edgeRtpParameters, localId;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (this._transportReady) {
                _context6.next = 5;
                break;
              }
              _context6.next = 5;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 5:
              logger.debug('send() | calling new RTCRtpSender()');
              rtpSender = new RTCRtpSender(track, this._dtlsTransport);
              rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
              rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
              useRtx = rtpParameters.codecs.some(function (_codec) {
                return /.+\/rtx$/i.test(_codec.mimeType);
              });
              if (!encodings) encodings = [{}];
              _iterator4 = _createForOfIteratorHelper(encodings);
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  encoding = _step4.value;
                  encoding.ssrc = utils.generateRandomNumber();
                  if (useRtx) encoding.rtx = {
                    ssrc: utils.generateRandomNumber()
                  };
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              rtpParameters.encodings = encodings;
              // Fill RTCRtpParameters.rtcp.
              rtpParameters.rtcp = {
                cname: this._cname,
                reducedSize: true,
                mux: true
              };
              // NOTE: Convert our standard RTCRtpParameters into those that Edge
              // expects.
              edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
              logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
              _context6.next = 19;
              return rtpSender.send(edgeRtpParameters);
            case 19:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              // Store it.
              this._rtpSenders.set(localId, rtpSender);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: rtpParameters,
                rtpSender: rtpSender
              });
            case 23:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var rtpSender;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              logger.debug('stopSending() [localId:%s]', localId);
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context7.next = 4;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 4:
              this._rtpSenders["delete"](localId);
              _context7.prev = 5;
              logger.debug('stopSending() | calling rtpSender.stop()');
              rtpSender.stop();
              _context7.next = 14;
              break;
            case 10:
              _context7.prev = 10;
              _context7.t0 = _context7["catch"](5);
              logger.warn('stopSending() | rtpSender.stop() failed:%o', _context7.t0);
              throw _context7.t0;
            case 14:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[5, 10]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var rtpSender;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context10.next = 4;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 4:
              rtpSender.setTrack(track);
            case 5:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var rtpSender, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context11.next = 4;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 4:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 8;
              return rtpSender.setParameters(parameters);
            case 8:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var rtpSender, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context12.next = 4;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 4:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 8;
              return rtpSender.setParameters(parameters);
            case 8:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var rtpSender;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              rtpSender = this._rtpSenders.get(localId);
              if (rtpSender) {
                _context13.next = 3;
                break;
              }
              throw new Error('RTCRtpSender not found');
            case 3:
              return _context13.abrupt("return", rtpSender.getStats());
            case 4:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      options) {
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var results, _iterator5, _step5, options, trackId, kind, _iterator6, _step6, _options, _trackId, _kind, rtpParameters, rtpReceiver, edgeRtpParameters, localId;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              results = [];
              _iterator5 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  options = _step5.value;
                  trackId = options.trackId, kind = options.kind;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              if (this._transportReady) {
                _context15.next = 6;
                break;
              }
              _context15.next = 6;
              return this.setupTransport({
                localDtlsRole: 'server'
              });
            case 6:
              _iterator6 = _createForOfIteratorHelper(optionsList);
              _context15.prev = 7;
              _iterator6.s();
            case 9:
              if ((_step6 = _iterator6.n()).done) {
                _context15.next = 24;
                break;
              }
              _options = _step6.value;
              _trackId = _options.trackId, _kind = _options.kind, rtpParameters = _options.rtpParameters;
              logger.debug('receive() | calling new RTCRtpReceiver()');
              rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, _kind);
              rtpReceiver.addEventListener('error', function (event) {
                logger.error('rtpReceiver "error" event [event:%o]', event);
              });
              // NOTE: Convert our standard RTCRtpParameters into those that Edge
              // expects.
              edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
              logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
              _context15.next = 19;
              return rtpReceiver.receive(edgeRtpParameters);
            case 19:
              localId = _trackId; // Store it.
              this._rtpReceivers.set(localId, rtpReceiver);
              results.push({
                localId: localId,
                track: rtpReceiver.track,
                rtpReceiver: rtpReceiver
              });
            case 22:
              _context15.next = 9;
              break;
            case 24:
              _context15.next = 29;
              break;
            case 26:
              _context15.prev = 26;
              _context15.t0 = _context15["catch"](7);
              _iterator6.e(_context15.t0);
            case 29:
              _context15.prev = 29;
              _iterator6.f();
              return _context15.finish(29);
            case 32:
              return _context15.abrupt("return", results);
            case 33:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this, [[7, 26, 29, 32]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator7, _step7, localId, rtpReceiver;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context16.prev = 1;
              _iterator7.s();
            case 3:
              if ((_step7 = _iterator7.n()).done) {
                _context16.next = 13;
                break;
              }
              localId = _step7.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              rtpReceiver = this._rtpReceivers.get(localId);
              if (rtpReceiver) {
                _context16.next = 9;
                break;
              }
              throw new Error('RTCRtpReceiver not found');
            case 9:
              this._rtpReceivers["delete"](localId);
              try {
                logger.debug('stopReceiving() | calling rtpReceiver.stop()');
                rtpReceiver.stop();
              } catch (error) {
                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);
              }
            case 11:
              _context16.next = 3;
              break;
            case 13:
              _context16.next = 18;
              break;
            case 15:
              _context16.prev = 15;
              _context16.t0 = _context16["catch"](1);
              _iterator7.e(_context16.t0);
            case 18:
              _context16.prev = 18;
              _iterator7.f();
              return _context16.finish(18);
            case 21:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[1, 15, 18, 21]]);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
            case "end":
              return _context17.stop();
          }
        }, _callee17);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
            case "end":
              return _context18.stop();
          }
        }, _callee18);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var rtpReceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              rtpReceiver = this._rtpReceivers.get(localId);
              if (rtpReceiver) {
                _context19.next = 3;
                break;
              }
              throw new Error('RTCRtpReceiver not found');
            case 3:
              return _context19.abrupt("return", rtpReceiver.getStats());
            case 4:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      options) {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setIceGatherer",
    value: function setIceGatherer(_ref3) {
      var iceServers = _ref3.iceServers,
        iceTransportPolicy = _ref3.iceTransportPolicy;
      // @ts-ignore
      var iceGatherer = new RTCIceGatherer({
        iceServers: iceServers || [],
        gatherPolicy: iceTransportPolicy || 'all'
      });
      iceGatherer.addEventListener('error', function (event) {
        logger.error('iceGatherer "error" event [event:%o]', event);
      });
      // NOTE: Not yet implemented by Edge, which starts gathering automatically.
      try {
        iceGatherer.gather();
      } catch (error) {
        logger.debug('setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());
      }
      this._iceGatherer = iceGatherer;
    }
  }, {
    key: "setIceTransport",
    value: function setIceTransport() {
      var _this2 = this;
      var iceTransport = new RTCIceTransport(this._iceGatherer);
      // NOTE: Not yet implemented by Edge.
      iceTransport.addEventListener('statechange', function () {
        switch (iceTransport.state) {
          case 'checking':
            _this2.emit('@connectionstatechange', 'connecting');
            break;
          case 'connected':
          case 'completed':
            _this2.emit('@connectionstatechange', 'connected');
            break;
          case 'failed':
            _this2.emit('@connectionstatechange', 'failed');
            break;
          case 'disconnected':
            _this2.emit('@connectionstatechange', 'disconnected');
            break;
          case 'closed':
            _this2.emit('@connectionstatechange', 'closed');
            break;
        }
      });
      // NOTE: Not standard, but implemented by Edge.
      iceTransport.addEventListener('icestatechange', function () {
        switch (iceTransport.state) {
          case 'checking':
            _this2.emit('@connectionstatechange', 'connecting');
            break;
          case 'connected':
          case 'completed':
            _this2.emit('@connectionstatechange', 'connected');
            break;
          case 'failed':
            _this2.emit('@connectionstatechange', 'failed');
            break;
          case 'disconnected':
            _this2.emit('@connectionstatechange', 'disconnected');
            break;
          case 'closed':
            _this2.emit('@connectionstatechange', 'closed');
            break;
        }
      });
      iceTransport.addEventListener('candidatepairchange', function (event) {
        logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
      });
      this._iceTransport = iceTransport;
    }
  }, {
    key: "setDtlsTransport",
    value: function setDtlsTransport() {
      var _this3 = this;
      var dtlsTransport = new RTCDtlsTransport(this._iceTransport);
      // NOTE: Not yet implemented by Edge.
      dtlsTransport.addEventListener('statechange', function () {
        logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
      });
      // NOTE: Not standard, but implemented by Edge.
      dtlsTransport.addEventListener('dtlsstatechange', function () {
        logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
        if (dtlsTransport.state === 'closed') _this3.emit('@connectionstatechange', 'closed');
      });
      dtlsTransport.addEventListener('error', function (event) {
        logger.error('dtlsTransport "error" event [event:%o]', event);
      });
      this._dtlsTransport = dtlsTransport;
    }
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref4) {
        var _this4 = this;
        var localDtlsRole, dtlsParameters, _iterator8, _step8, candidate;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              localDtlsRole = _ref4.localDtlsRole;
              logger.debug('setupTransport()');
              // Get our local DTLS parameters.
              dtlsParameters = this._dtlsTransport.getLocalParameters();
              dtlsParameters.role = localDtlsRole;
              // Need to tell the remote transport about our parameters.
              _context21.next = 6;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 6:
              // Start the RTCIceTransport.
              this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');
              // Add remote ICE candidates.
              _iterator8 = _createForOfIteratorHelper(this._remoteIceCandidates);
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  candidate = _step8.value;
                  this._iceTransport.addRemoteCandidate(candidate);
                }
                // Also signal a 'complete' candidate as per spec.
                // NOTE: It should be {complete: true} but Edge prefers {}.
                // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
                // won't enter the 'completed' state.
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
              this._iceTransport.addRemoteCandidate({});
              // NOTE: Edge does not like SHA less than 256.
              this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter(function (fingerprint) {
                return fingerprint.algorithm === 'sha-256' || fingerprint.algorithm === 'sha-384' || fingerprint.algorithm === 'sha-512';
              });
              // Start the RTCDtlsTransport.
              this._dtlsTransport.start(this._remoteDtlsParameters);
              this._transportReady = true;
            case 13:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Edge11();
      };
    }
  }]);
  return Edge11;
}(HandlerInterface_1.HandlerInterface);
exports.Edge11 = Edge11;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Firefox60.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox60.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Firefox60 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var logger = new Logger_1.Logger('Firefox60');
var SCTP_NUM_STREAMS = {
  OS: 16,
  MIS: 2048
};
var Firefox60 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Firefox60, _HandlerInterface_1$H);
  var _super = _createSuper(Firefox60);
  function Firefox60() {
    var _this;
    _classCallCheck(this, Firefox60);
    _this = _super.call(this);
    // Map of RTCTransceivers indexed by MID.
    _this._mapMidTransceiver = new Map();
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Firefox60, [{
    key: "name",
    get: function get() {
      return 'Firefox60';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, canvas, fakeStream, fakeVideoTrack, videoTransceiver, parameters, encodings, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
              }); // NOTE: We need to add a real video track to get the RID extension mapping.
              canvas = document.createElement('canvas'); // NOTE: Otherwise Firefox fails in next line.
              canvas.getContext('2d');
              fakeStream = canvas.captureStream();
              fakeVideoTrack = fakeStream.getVideoTracks()[0];
              _context.prev = 6;
              pc.addTransceiver('audio', {
                direction: 'sendrecv'
              });
              videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
                direction: 'sendrecv'
              });
              parameters = videoTransceiver.sender.getParameters();
              encodings = [{
                rid: 'r0',
                maxBitrate: 100000
              }, {
                rid: 'r1',
                maxBitrate: 500000
              }];
              parameters.encodings = encodings;
              _context.next = 14;
              return videoTransceiver.sender.setParameters(parameters);
            case 14:
              _context.next = 16;
              return pc.createOffer();
            case 16:
              offer = _context.sent;
              try {
                canvas.remove();
              } catch (error) {}
              try {
                fakeVideoTrack.stop();
              } catch (error) {}
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 25:
              _context.prev = 25;
              _context.t0 = _context["catch"](6);
              try {
                canvas.remove();
              } catch (error2) {}
              try {
                fakeVideoTrack.stop();
              } catch (error2) {}
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 31:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[6, 25]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              throw new errors_1.UnsupportedError('not supported');
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, transceiver, parameters, offer, localSdpObject, localId, offerMediaObject, newEncodings, _iterator, _step, encoding, answer;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings) {
                encodings = utils.clone(encodings, []);
                if (encodings.length > 1) {
                  encodings.forEach(function (encoding, idx) {
                    encoding.rid = "r".concat(idx);
                  });
                  // Clone the encodings and reverse them because Firefox likes them
                  // from high to low.
                  encodings.reverse();
                }
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              // NOTE: Firefox fails sometimes to properly anticipate the closed media
              // section that it should use, so don't reuse closed media sections.
              //   https://github.com/versatica/mediasoup-client/issues/104
              //
              // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              }); // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
              // second argument, but Firefox does not support it.
              if (!encodings) {
                _context6.next = 14;
                break;
              }
              parameters = transceiver.sender.getParameters();
              parameters.encodings = encodings;
              _context6.next = 14;
              return transceiver.sender.setParameters(parameters);
            case 14:
              _context6.next = 16;
              return this._pc.createOffer();
            case 16:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp); // In Firefox use DTLS role client even if we are the "offerer" since
              // Firefox does not respect ICE-Lite.
              if (this._transportReady) {
                _context6.next = 21;
                break;
              }
              _context6.next = 21;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 21:
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 24;
              return this._pc.setLocalDescription(offer);
            case 24:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1]; // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                _extends(newEncodings[0], encodings[0]);
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim (but
              // reverse them back since we reversed them above to satisfy Firefox).
              else {
                sendingRtpParameters.encodings = encodings.reverse();
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions,
                extmapAllowMixed: true
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 36;
              return this._pc.setRemoteDescription(answer);
            case 36:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
            case 38:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.next = 4;
                break;
              }
              throw new Error('associated transceiver not found');
            case 4:
              transceiver.sender.replaceTrack(null);
              // NOTE: Cannot use stop() the transceiver due to the the note above in
              // send() method.
              // try
              // {
              // 	transceiver.stop();
              // }
              // catch (error)
              // {}
              this._pc.removeTrack(transceiver.sender);
              // NOTE: Cannot use closeMediaSection() due to the the note above in send()
              // method.
              // this._remoteSdp!.closeMediaSection(transceiver.mid);
              this._remoteSdp.disableMediaSection(transceiver.mid);
              _context7.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
              this._mapMidTransceiver["delete"](localId);
            case 18:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context8.sent;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context9.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context9.sent;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              _context10.next = 7;
              return transceiver.sender.replaceTrack(track);
            case 7:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated transceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters(); // NOTE: We require encodings given from low to high, however Firefox
              // requires them in reverse order, so do magic here.
              spatialLayer = parameters.encodings.length - 1 - spatialLayer;
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx >= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 10;
              return transceiver.sender.setParameters(parameters);
            case 10:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context13.abrupt("return", transceiver.sender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      optionsList) {
        var _this3 = this;
        var results, mapLocalId, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.next = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 14;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                      answer = {
                        type: 'answer',
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    case 6:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 17:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 21;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 19);
            case 19:
              _context17.next = 17;
              break;
            case 21:
              _context17.next = 26;
              break;
            case 23:
              _context17.prev = 23;
              _context17.t1 = _context17["catch"](14);
              _iterator3.e(_context17.t1);
            case 26:
              _context17.prev = 26;
              _iterator3.f();
              return _context17.finish(26);
            case 29:
              if (this._transportReady) {
                _context17.next = 32;
                break;
              }
              _context17.next = 32;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 32:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 35;
              return this._pc.setLocalDescription(answer);
            case 35:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 36;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context16.next = 6;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 6:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 8:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 39:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 43;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 41);
            case 41:
              _context17.next = 39;
              break;
            case 43:
              _context17.next = 48;
              break;
            case 45:
              _context17.prev = 45;
              _context17.t3 = _context17["catch"](36);
              _iterator4.e(_context17.t3);
            case 48:
              _context17.prev = 48;
              _iterator4.f();
              return _context17.finish(48);
            case 51:
              return _context17.abrupt("return", results);
            case 52:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[14, 23, 26, 29], [36, 45, 48, 51]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context18.prev = 2;
              _iterator5.s();
            case 4:
              if ((_step5 = _iterator5.n()).done) {
                _context18.next = 13;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 11:
              _context18.next = 4;
              break;
            case 13:
              _context18.next = 18;
              break;
            case 15:
              _context18.prev = 15;
              _context18.t0 = _context18["catch"](2);
              _iterator5.e(_context18.t0);
            case 18:
              _context18.prev = 18;
              _iterator5.f();
              return _context18.finish(18);
            case 21:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 25;
              return this._pc.setRemoteDescription(offer);
            case 25:
              _context18.next = 27;
              return this._pc.createAnswer();
            case 27:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 31;
              return this._pc.setLocalDescription(answer);
            case 31:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 33:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this, [[2, 15, 18, 21]]);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context19.prev = 2;
              _iterator7.s();
            case 4:
              if ((_step7 = _iterator7.n()).done) {
                _context19.next = 14;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 12:
              _context19.next = 4;
              break;
            case 14:
              _context19.next = 19;
              break;
            case 16:
              _context19.prev = 16;
              _context19.t0 = _context19["catch"](2);
              _iterator7.e(_context19.t0);
            case 19:
              _context19.prev = 19;
              _iterator7.f();
              return _context19.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context19.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context19.sent;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context19.stop();
          }
        }, _callee17, this, [[2, 16, 19, 22]]);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context20.prev = 2;
              _iterator8.s();
            case 4:
              if ((_step8 = _iterator8.n()).done) {
                _context20.next = 14;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 12:
              _context20.next = 4;
              break;
            case 14:
              _context20.next = 19;
              break;
            case 16:
              _context20.prev = 16;
              _context20.t0 = _context20["catch"](2);
              _iterator8.e(_context20.t0);
            case 19:
              _context20.prev = 19;
              _iterator8.f();
              return _context20.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context20.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context20.sent;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context20.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context20.stop();
          }
        }, _callee18, this, [[2, 16, 19, 22]]);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context21.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context21.abrupt("return", transceiver.receiver.getStats());
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref4) {
        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Firefox60();
      };
    }
  }]);
  return Firefox60;
}(HandlerInterface_1.HandlerInterface);
exports.Firefox60 = Firefox60;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HandlerInterface = void 0;
var EnhancedEventEmitter_1 = __webpack_require__(/*! ../EnhancedEventEmitter */ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js");
var HandlerInterface = /*#__PURE__*/function (_EnhancedEventEmitter) {
  _inherits(HandlerInterface, _EnhancedEventEmitter);
  var _super = _createSuper(HandlerInterface);
  function HandlerInterface() {
    _classCallCheck(this, HandlerInterface);
    return _super.call(this);
  }
  return _createClass(HandlerInterface);
}(EnhancedEventEmitter_1.EnhancedEventEmitter);
exports.HandlerInterface = HandlerInterface;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ReactNative.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNative.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactNative = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/mediasoup-client/lib/errors.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var logger = new Logger_1.Logger('ReactNative');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var ReactNative = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(ReactNative, _HandlerInterface_1$H);
  var _super = _createSuper(ReactNative);
  function ReactNative() {
    var _this;
    _classCallCheck(this, ReactNative);
    _this = _super.call(this);
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Map of sending MediaStreamTracks indexed by localId.
    _this._mapSendLocalIdTrack = new Map();
    // Next sending localId.
    _this._nextSendLocalId = 0;
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _this._mapRecvLocalIdInfo = new Map();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(ReactNative, [{
    key: "name",
    get: function get() {
      return 'ReactNative';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Free/dispose native MediaStream but DO NOT free/dispose native
      // MediaStreamTracks (that is parent's business).
      // @ts-ignore (proprietary API in react-native-webrtc).
      this._sendStream.release( /* releaseTracks */false);
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.prev = 2;
              _context.next = 5;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 5:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 12]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'plan-b'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addStream(this._sendStream);
              _context6.next = 8;
              return this._pc.createOffer();
            case 8:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.next = 17;
                break;
              }
              _context6.next = 17;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 21;
              return this._pc.setLocalDescription(offer);
            case 21:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) _extends(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 32;
              return this._pc.setRemoteDescription(answer);
            case 32:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              // Insert into the map.
              this._mapSendLocalIdTrack.set(localId, track);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters
              });
            case 36:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var track, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              track = this._mapSendLocalIdTrack.get(localId);
              if (track) {
                _context7.next = 5;
                break;
              }
              throw new Error('track not found');
            case 5:
              this._mapSendLocalIdTrack["delete"](localId);
              this._sendStream.removeTrack(track);
              this._pc.addStream(this._sendStream);
              _context7.next = 10;
              return this._pc.createOffer();
            case 10:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.prev = 12;
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              _context7.next = 23;
              break;
            case 17:
              _context7.prev = 17;
              _context7.t0 = _context7["catch"](12);
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.next = 22;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());
              return _context7.abrupt("return");
            case 22:
              throw _context7.t0;
            case 23:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.next = 25;
                break;
              }
              return _context7.abrupt("return");
            case 25:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 29;
              return this._pc.setRemoteDescription(answer);
            case 29:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[12, 17]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId, track) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, mapStreamId, _iterator2, _step2, options, trackId, kind, rtpParameters, mid, streamId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapStreamId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  streamId = options.streamId || rtpParameters.rtcp.cname; // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
                  // remote tracks. This is because react-native-webrtc does not react on new
                  // tracks generated within already existing streams, so force the streamId
                  // to be different. See:
                  // https://github.com/react-native-webrtc/react-native-webrtc/issues/401
                  logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');
                  streamId += "-hack-".concat(utils.generateRandomNumber());
                  mapStreamId.set(trackId, streamId);
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.next = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 14;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 17:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 21;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 19);
            case 19:
              _context17.next = 17;
              break;
            case 21:
              _context17.next = 26;
              break;
            case 23:
              _context17.prev = 23;
              _context17.t1 = _context17["catch"](14);
              _iterator3.e(_context17.t1);
            case 26:
              _context17.prev = 26;
              _iterator3.f();
              return _context17.finish(26);
            case 29:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 33;
                break;
              }
              _context17.next = 33;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 33:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 36;
              return this._pc.setLocalDescription(answer);
            case 36:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 37;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, kind, trackId, rtpParameters, localId, mid, streamId, stream, track;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = trackId;
                      mid = kind;
                      streamId = mapStreamId.get(trackId);
                      stream = _this3._pc.getRemoteStreams().find(function (s) {
                        return s.id === streamId;
                      });
                      track = stream.getTrackById(localId);
                      if (track) {
                        _context16.next = 9;
                        break;
                      }
                      throw new Error('remote track not found');
                    case 9:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters
                      });
                      results.push({
                        localId: localId,
                        track: track
                      });
                    case 11:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 40:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 44;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 42);
            case 42:
              _context17.next = 40;
              break;
            case 44:
              _context17.next = 49;
              break;
            case 46:
              _context17.prev = 46;
              _context17.t3 = _context17["catch"](37);
              _iterator4.e(_context17.t3);
            case 49:
              _context17.prev = 49;
              _iterator4.f();
              return _context17.finish(49);
            case 52:
              return _context17.abrupt("return", results);
            case 53:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[14, 23, 26, 29], [37, 46, 49, 52]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 7;
              return this._pc.setRemoteDescription(offer);
            case 7:
              _context18.next = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 13;
              return this._pc.setLocalDescription(answer);
            case 13:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
            case "end":
              return _context19.stop();
          }
        }, _callee17);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
            case "end":
              return _context20.stop();
          }
        }, _callee18);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              throw new errors_1.UnsupportedError('not implemented');
            case 1:
            case "end":
              return _context21.stop();
          }
        }, _callee19);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref5) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmitTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref6) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new ReactNative();
      };
    }
  }]);
  return ReactNative;
}(HandlerInterface_1.HandlerInterface);
exports.ReactNative = ReactNative;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactNativeUnifiedPlan = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
var logger = new Logger_1.Logger('ReactNativeUnifiedPlan');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var ReactNativeUnifiedPlan = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(ReactNativeUnifiedPlan, _HandlerInterface_1$H);
  var _super = _createSuper(ReactNativeUnifiedPlan);
  function ReactNativeUnifiedPlan() {
    var _this;
    _classCallCheck(this, ReactNativeUnifiedPlan);
    _this = _super.call(this);
    // Map of RTCTransceivers indexed by MID.
    _this._mapMidTransceiver = new Map();
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(ReactNativeUnifiedPlan, [{
    key: "name",
    get: function get() {
      return 'ReactNativeUnifiedPlan';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Free/dispose native MediaStream but DO NOT free/dispose native
      // MediaStreamTracks (that is parent's business).
      // @ts-ignore (proprietary API in react-native-webrtc).
      this._sendStream.release( /* releaseTracks */false);
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
              });
              _context.prev = 2;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.next = 7;
              return pc.createOffer();
            case 7:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 14]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, hackVp9Svc, layers, localId, newEncodings, _iterator, _step, encoding, answer;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (encodings && encodings.length > 1) {
                encodings.forEach(function (encoding, idx) {
                  encoding.rid = "r".concat(idx);
                });
              }
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream],
                sendEncodings: encodings
              });
              _context6.next = 12;
              return this._pc.createOffer();
            case 12:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (this._transportReady) {
                _context6.next = 17;
                break;
              }
              _context6.next = 17;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              // Special case for VP9 with SVC.
              hackVp9Svc = false;
              layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
              if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
                logger.debug('send() | enabling legacy simulcast for VP9 SVC');
                hackVp9Svc = true;
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: layers.spatialLayers
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 23;
              return this._pc.setLocalDescription(offer);
            case 23:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings by parsing the SDP offer if no encodings are given.
              if (!encodings) {
                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
              }
              // Set RTP encodings by parsing the SDP offer and complete them with given
              // one if just a single encoding has been given.
              else if (encodings.length === 1) {
                newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                  offerMediaObject: offerMediaObject
                });
                _extends(newEncodings[0], encodings[0]);
                // Hack for VP9 SVC.
                if (hackVp9Svc) newEncodings = [newEncodings[0]];
                sendingRtpParameters.encodings = newEncodings;
              }
              // Otherwise if more than 1 encoding are given use them verbatim.
              else {
                sendingRtpParameters.encodings = encodings;
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions,
                extmapAllowMixed: true
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 35;
              return this._pc.setRemoteDescription(answer);
            case 35:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
            case 37:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.next = 11;
              return this._pc.createOffer();
            case 11:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 19;
              return this._pc.setRemoteDescription(answer);
            case 19:
              this._mapMidTransceiver["delete"](localId);
            case 20:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }()
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context8.sent;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }()
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              this._remoteSdp.resumeSendingMediaSection(localId);
              if (transceiver) {
                _context9.next = 6;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 6:
              transceiver.direction = 'sendonly';
              _context9.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context9.sent;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              _context10.next = 7;
              return transceiver.sender.replaceTrack(track);
            case 7:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context13.abrupt("return", transceiver.sender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, mapLocalId, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.next = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 14;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 17:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 21;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 19);
            case 19:
              _context17.next = 17;
              break;
            case 21:
              _context17.next = 26;
              break;
            case 23:
              _context17.prev = 23;
              _context17.t1 = _context17["catch"](14);
              _iterator3.e(_context17.t1);
            case 26:
              _context17.prev = 26;
              _iterator3.f();
              return _context17.finish(26);
            case 29:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 33;
                break;
              }
              _context17.next = 33;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 33:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 36;
              return this._pc.setLocalDescription(answer);
            case 36:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 37;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context16.next = 8;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 8:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 10:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 40:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 44;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 42);
            case 42:
              _context17.next = 40;
              break;
            case 44:
              _context17.next = 49;
              break;
            case 46:
              _context17.prev = 46;
              _context17.t3 = _context17["catch"](37);
              _iterator4.e(_context17.t3);
            case 49:
              _context17.prev = 49;
              _iterator4.f();
              return _context17.finish(49);
            case 52:
              return _context17.abrupt("return", results);
            case 53:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[14, 23, 26, 29], [37, 46, 49, 52]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context18.prev = 2;
              _iterator5.s();
            case 4:
              if ((_step5 = _iterator5.n()).done) {
                _context18.next = 13;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 11:
              _context18.next = 4;
              break;
            case 13:
              _context18.next = 18;
              break;
            case 15:
              _context18.prev = 15;
              _context18.t0 = _context18["catch"](2);
              _iterator5.e(_context18.t0);
            case 18:
              _context18.prev = 18;
              _iterator5.f();
              return _context18.finish(18);
            case 21:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 25;
              return this._pc.setRemoteDescription(offer);
            case 25:
              _context18.next = 27;
              return this._pc.createAnswer();
            case 27:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 31;
              return this._pc.setLocalDescription(answer);
            case 31:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 33:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this, [[2, 15, 18, 21]]);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context19.prev = 2;
              _iterator7.s();
            case 4:
              if ((_step7 = _iterator7.n()).done) {
                _context19.next = 14;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 12:
              _context19.next = 4;
              break;
            case 14:
              _context19.next = 19;
              break;
            case 16:
              _context19.prev = 16;
              _context19.t0 = _context19["catch"](2);
              _iterator7.e(_context19.t0);
            case 19:
              _context19.prev = 19;
              _iterator7.f();
              return _context19.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context19.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context19.sent;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context19.stop();
          }
        }, _callee17, this, [[2, 16, 19, 22]]);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context20.prev = 2;
              _iterator8.s();
            case 4:
              if ((_step8 = _iterator8.n()).done) {
                _context20.next = 14;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 12:
              _context20.next = 4;
              break;
            case 14:
              _context20.next = 19;
              break;
            case 16:
              _context20.prev = 16;
              _context20.t0 = _context20["catch"](2);
              _iterator8.e(_context20.t0);
            case 19:
              _context20.prev = 19;
              _iterator8.f();
              return _context20.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context20.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context20.sent;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context20.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context20.stop();
          }
        }, _callee18, this, [[2, 16, 19, 22]]);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context21.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context21.abrupt("return", transceiver.receiver.getStats());
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref4) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new ReactNativeUnifiedPlan();
      };
    }
  }]);
  return ReactNativeUnifiedPlan;
}(HandlerInterface_1.HandlerInterface);
exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari11.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari11.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Safari11 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var logger = new Logger_1.Logger('Safari11');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Safari11 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Safari11, _HandlerInterface_1$H);
  var _super = _createSuper(Safari11);
  function Safari11() {
    var _this;
    _classCallCheck(this, Safari11);
    _this = _super.call(this);
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Map of RTCRtpSender indexed by localId.
    _this._mapSendLocalIdRtpSender = new Map();
    // Next sending localId.
    _this._nextSendLocalId = 0;
    // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
    // Value is an Object with mid, rtpParameters and rtpReceiver.
    _this._mapRecvLocalIdInfo = new Map();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Safari11, [{
    key: "name",
    get: function get() {
      return 'Safari11';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'plan-b'
              });
              _context.prev = 2;
              _context.next = 5;
              return pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
              });
            case 5:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 12]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters,
        planB: true
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId, rtpSender;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              if (codec) {
                logger.warn('send() | codec selection is not available in %s handler', this.name);
              }
              this._sendStream.addTrack(track);
              this._pc.addTrack(track, this._sendStream);
              _context6.next = 8;
              return this._pc.createOffer();
            case 8:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
              if (this._transportReady) {
                _context6.next = 17;
                break;
              }
              _context6.next = 17;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 17:
              if (track.kind === 'video' && encodings && encodings.length > 1) {
                logger.debug('send() | enabling simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media.find(function (m) {
                  return m.type === 'video';
                });
                sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  track: track,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 21;
              return this._pc.setLocalDescription(offer);
            case 21:
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === track.kind;
              });
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject,
                track: track
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) _extends(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
              }
              // If VP8 and there is effective simulcast, add scalabilityMode to each
              // encoding.
              if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 32;
              return this._pc.setRemoteDescription(answer);
            case 32:
              localId = String(this._nextSendLocalId);
              this._nextSendLocalId++;
              rtpSender = this._pc.getSenders().find(function (s) {
                return s.track === track;
              }); // Insert into the map.
              this._mapSendLocalIdRtpSender.set(localId, rtpSender);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: rtpSender
              });
            case 37:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var rtpSender, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context7.next = 4;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 4:
              if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);
              this._mapSendLocalIdRtpSender["delete"](localId);
              _context7.next = 8;
              return this._pc.createOffer();
            case 8:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.prev = 10;
              _context7.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              _context7.next = 21;
              break;
            case 15:
              _context7.prev = 15;
              _context7.t0 = _context7["catch"](10);
              if (!(this._sendStream.getTracks().length === 0)) {
                _context7.next = 20;
                break;
              }
              logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());
              return _context7.abrupt("return");
            case 20:
              throw _context7.t0;
            case 21:
              if (!(this._pc.signalingState === 'stable')) {
                _context7.next = 23;
                break;
              }
              return _context7.abrupt("return");
            case 23:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 27;
              return this._pc.setRemoteDescription(answer);
            case 27:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[10, 15]]);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var rtpSender, oldTrack;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              oldTrack = rtpSender.track;
              _context10.next = 8;
              return rtpSender.replaceTrack(track);
            case 8:
              // Remove the old track from the local stream.
              if (oldTrack) this._sendStream.removeTrack(oldTrack);
              // Add the new track to the local stream.
              if (track) this._sendStream.addTrack(track);
            case 10:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var rtpSender, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 9;
              return rtpSender.setParameters(parameters);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var rtpSender, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 5:
              parameters = rtpSender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return rtpSender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var rtpSender;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              rtpSender = this._mapSendLocalIdRtpSender.get(localId);
              if (rtpSender) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpSender not found');
            case 4:
              return _context13.abrupt("return", rtpSender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, mid, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  mid = kind;
                  this._remoteSdp.receive({
                    mid: mid,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 8;
              return this._pc.setRemoteDescription(offer);
            case 8:
              _context17.next = 10;
              return this._pc.createAnswer();
            case 10:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 13;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, kind, rtpParameters, mid, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      kind = options.kind, rtpParameters = options.rtpParameters;
                      mid = kind;
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === mid;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 16:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 20;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 18);
            case 18:
              _context17.next = 16;
              break;
            case 20:
              _context17.next = 25;
              break;
            case 22:
              _context17.prev = 22;
              _context17.t1 = _context17["catch"](13);
              _iterator3.e(_context17.t1);
            case 25:
              _context17.prev = 25;
              _iterator3.f();
              return _context17.finish(25);
            case 28:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 32;
                break;
              }
              _context17.next = 32;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 32:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 35;
              return this._pc.setLocalDescription(answer);
            case 35:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 36;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, kind, trackId, rtpParameters, mid, localId, rtpReceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      kind = options.kind, trackId = options.trackId, rtpParameters = options.rtpParameters;
                      mid = kind;
                      localId = trackId;
                      rtpReceiver = _this3._pc.getReceivers().find(function (r) {
                        return r.track && r.track.id === localId;
                      });
                      if (rtpReceiver) {
                        _context16.next = 7;
                        break;
                      }
                      throw new Error('new RTCRtpReceiver not');
                    case 7:
                      // Insert into the map.
                      _this3._mapRecvLocalIdInfo.set(localId, {
                        mid: mid,
                        rtpParameters: rtpParameters,
                        rtpReceiver: rtpReceiver
                      });
                      results.push({
                        localId: localId,
                        track: rtpReceiver.track,
                        rtpReceiver: rtpReceiver
                      });
                    case 9:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 39:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 43;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 41);
            case 41:
              _context17.next = 39;
              break;
            case 43:
              _context17.next = 48;
              break;
            case 45:
              _context17.prev = 45;
              _context17.t3 = _context17["catch"](36);
              _iterator4.e(_context17.t3);
            case 48:
              _context17.prev = 48;
              _iterator4.f();
              return _context17.finish(48);
            case 51:
              return _context17.abrupt("return", results);
            case 52:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[13, 22, 25, 28], [36, 45, 48, 51]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, _ref4, mid, rtpParameters, offer, answer;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  localId = _step5.value;
                  logger.debug('stopReceiving() [localId:%s]', localId);
                  _ref4 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref4.mid, rtpParameters = _ref4.rtpParameters; // Remove from the map.
                  this._mapRecvLocalIdInfo["delete"](localId);
                  this._remoteSdp.planBStopReceiving({
                    mid: mid,
                    offerRtpParameters: rtpParameters
                  });
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 7;
              return this._pc.setRemoteDescription(offer);
            case 7:
              _context18.next = 9;
              return this._pc.createAnswer();
            case 9:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 13;
              return this._pc.setLocalDescription(answer);
            case 13:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(localId) {
        var _ref5, rtpReceiver;
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              this.assertRecvDirection();
              _ref5 = this._mapRecvLocalIdInfo.get(localId) || {}, rtpReceiver = _ref5.rtpReceiver;
              if (rtpReceiver) {
                _context19.next = 4;
                break;
              }
              throw new Error('associated RTCRtpReceiver not found');
            case 4:
              return _context19.abrupt("return", rtpReceiver.getStats());
            case 5:
            case "end":
              return _context19.stop();
          }
        }, _callee17, this);
      }));
      function getReceiverStats(_x17) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
            case "end":
              return _context20.stop();
          }
        }, _callee18);
      }));
      function pauseReceiving(_x18) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localIds) {
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
            case "end":
              return _context21.stop();
          }
        }, _callee19);
      }));
      function resumeReceiving(_x19) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref6) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref6.sctpStreamParameters, label = _ref6.label, protocol = _ref6.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
              });
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref7) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref7.localDtlsRole, localSdpObject = _ref7.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Safari11();
      };
    }
  }]);
  return Safari11;
}(HandlerInterface_1.HandlerInterface);
exports.Safari11 = Safari11;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari12.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari12.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Safari12 = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var utils = __importStar(__webpack_require__(/*! ../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var ortc = __importStar(__webpack_require__(/*! ../ortc */ "./node_modules/mediasoup-client/lib/ortc.js"));
var sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"));
var sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"));
var HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js");
var RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js");
var logger = new Logger_1.Logger('Safari12');
var SCTP_NUM_STREAMS = {
  OS: 1024,
  MIS: 1024
};
var Safari12 = /*#__PURE__*/function (_HandlerInterface_1$H) {
  _inherits(Safari12, _HandlerInterface_1$H);
  var _super = _createSuper(Safari12);
  function Safari12() {
    var _this;
    _classCallCheck(this, Safari12);
    _this = _super.call(this);
    // Map of RTCTransceivers indexed by MID.
    _this._mapMidTransceiver = new Map();
    // Local stream for sending.
    _this._sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _this._hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _this._nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _this._transportReady = false;
    return _this;
  }
  _createClass(Safari12, [{
    key: "name",
    get: function get() {
      return 'Safari12';
    }
  }, {
    key: "close",
    value: function close() {
      logger.debug('close()');
      // Close RTCPeerConnection.
      if (this._pc) {
        try {
          this._pc.close();
        } catch (error) {}
      }
      this.emit('@close');
    }
  }, {
    key: "getNativeRtpCapabilities",
    value: function () {
      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pc, offer, sdpObject, nativeRtpCapabilities;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logger.debug('getNativeRtpCapabilities()');
              pc = new RTCPeerConnection({
                iceServers: [],
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
              });
              _context.prev = 2;
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              _context.next = 7;
              return pc.createOffer();
            case 7:
              offer = _context.sent;
              try {
                pc.close();
              } catch (error) {}
              sdpObject = sdpTransform.parse(offer.sdp);
              nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject: sdpObject
              });
              return _context.abrupt("return", nativeRtpCapabilities);
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](2);
              try {
                pc.close();
              } catch (error2) {}
              throw _context.t0;
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 14]]);
      }));
      function getNativeRtpCapabilities() {
        return _getNativeRtpCapabilities.apply(this, arguments);
      }
      return getNativeRtpCapabilities;
    }()
  }, {
    key: "getNativeSctpCapabilities",
    value: function () {
      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('getNativeSctpCapabilities()');
              return _context2.abrupt("return", {
                numStreams: SCTP_NUM_STREAMS
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getNativeSctpCapabilities() {
        return _getNativeSctpCapabilities.apply(this, arguments);
      }
      return getNativeSctpCapabilities;
    }()
  }, {
    key: "run",
    value: function run(_ref) {
      var _this2 = this;
      var direction = _ref.direction,
        iceParameters = _ref.iceParameters,
        iceCandidates = _ref.iceCandidates,
        dtlsParameters = _ref.dtlsParameters,
        sctpParameters = _ref.sctpParameters,
        iceServers = _ref.iceServers,
        iceTransportPolicy = _ref.iceTransportPolicy,
        additionalSettings = _ref.additionalSettings,
        proprietaryConstraints = _ref.proprietaryConstraints,
        extendedRtpCapabilities = _ref.extendedRtpCapabilities;
      logger.debug('run()');
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters: iceParameters,
        iceCandidates: iceCandidates,
        dtlsParameters: dtlsParameters,
        sctpParameters: sctpParameters
      });
      this._sendingRtpParametersByKind = {
        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
      };
      this._sendingRemoteRtpParametersByKind = {
        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
      };
      if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
        this._forcedLocalDtlsRole = dtlsParameters.role === 'server' ? 'client' : 'server';
      }
      this._pc = new RTCPeerConnection(_objectSpread({
        iceServers: iceServers || [],
        iceTransportPolicy: iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      }, additionalSettings), proprietaryConstraints);
      if (this._pc.connectionState) {
        this._pc.addEventListener('connectionstatechange', function () {
          _this2.emit('@connectionstatechange', _this2._pc.connectionState);
        });
      } else {
        this._pc.addEventListener('iceconnectionstatechange', function () {
          logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
          switch (_this2._pc.iceConnectionState) {
            case 'checking':
              _this2.emit('@connectionstatechange', 'connecting');
              break;
            case 'connected':
            case 'completed':
              _this2.emit('@connectionstatechange', 'connected');
              break;
            case 'failed':
              _this2.emit('@connectionstatechange', 'failed');
              break;
            case 'disconnected':
              _this2.emit('@connectionstatechange', 'disconnected');
              break;
            case 'closed':
              _this2.emit('@connectionstatechange', 'closed');
              break;
          }
        });
      }
    }
  }, {
    key: "updateIceServers",
    value: function () {
      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iceServers) {
        var configuration;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              logger.debug('updateIceServers()');
              configuration = this._pc.getConfiguration();
              configuration.iceServers = iceServers;
              this._pc.setConfiguration(configuration);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateIceServers(_x) {
        return _updateIceServers.apply(this, arguments);
      }
      return updateIceServers;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(iceParameters) {
        var offer, answer, _offer, _answer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              logger.debug('restartIce()');
              // Provide the remote SDP handler with new remote ICE parameters.
              this._remoteSdp.updateIceParameters(iceParameters);
              if (this._transportReady) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return");
            case 4:
              if (!(this._direction === 'send')) {
                _context4.next = 17;
                break;
              }
              _context4.next = 7;
              return this._pc.createOffer({
                iceRestart: true
              });
            case 7:
              offer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context4.next = 11;
              return this._pc.setLocalDescription(offer);
            case 11:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context4.next = 15;
              return this._pc.setRemoteDescription(answer);
            case 15:
              _context4.next = 27;
              break;
            case 17:
              _offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);
              _context4.next = 21;
              return this._pc.setRemoteDescription(_offer);
            case 21:
              _context4.next = 23;
              return this._pc.createAnswer();
            case 23:
              _answer = _context4.sent;
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);
              _context4.next = 27;
              return this._pc.setLocalDescription(_answer);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restartIce(_x2) {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "getTransportStats",
    value: function () {
      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this._pc.getStats());
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getTransportStats() {
        return _getTransportStats.apply(this, arguments);
      }
      return getTransportStats;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {
        var track, encodings, codecOptions, codec, _a, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, localId, idx, _iterator, _step, encoding, answer;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;
              this.assertSendDirection();
              logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
              sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
              sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {}); // This may throw.
              sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
              mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
              transceiver = this._pc.addTransceiver(track, {
                direction: 'sendonly',
                streams: [this._sendStream]
              });
              _context6.next = 11;
              return this._pc.createOffer();
            case 11:
              offer = _context6.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              if (this._transportReady) {
                _context6.next = 16;
                break;
              }
              _context6.next = 16;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 16:
              if (encodings && encodings.length > 1) {
                logger.debug('send() | enabling legacy simulcast');
                localSdpObject = sdpTransform.parse(offer.sdp);
                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject: offerMediaObject,
                  numStreams: encodings.length
                });
                offer = {
                  type: 'offer',
                  sdp: sdpTransform.write(localSdpObject)
                };
              }
              logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context6.next = 20;
              return this._pc.setLocalDescription(offer);
            case 20:
              // We can now get the transceiver.mid.
              localId = transceiver.mid; // Set MID.
              sendingRtpParameters.mid = localId;
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              // Set RTCP CNAME.
              sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                offerMediaObject: offerMediaObject
              });
              // Set RTP encodings.
              sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject: offerMediaObject
              });
              // Complete encodings with given values.
              if (encodings) {
                for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx]) _extends(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
              }
              // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
              // each encoding.
              if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
                _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    encoding = _step.value;
                    encoding.scalabilityMode = 'S1T3';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              this._remoteSdp.send({
                offerMediaObject: offerMediaObject,
                reuseMid: mediaSectionIdx.reuseMid,
                offerRtpParameters: sendingRtpParameters,
                answerRtpParameters: sendingRemoteRtpParameters,
                codecOptions: codecOptions
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context6.next = 33;
              return this._pc.setRemoteDescription(answer);
            case 33:
              // Store in the map.
              this._mapMidTransceiver.set(localId, transceiver);
              return _context6.abrupt("return", {
                localId: localId,
                rtpParameters: sendingRtpParameters,
                rtpSender: transceiver.sender
              });
            case 35:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function send(_x3) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "stopSending",
    value: function () {
      var _stopSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localId) {
        var transceiver, mediaSectionClosed, offer, answer;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('stopSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context7.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.sender.replaceTrack(null);
              this._pc.removeTrack(transceiver.sender);
              mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
              if (mediaSectionClosed) {
                try {
                  transceiver.stop();
                } catch (error) {}
              }
              _context7.next = 11;
              return this._pc.createOffer();
            case 11:
              offer = _context7.sent;
              logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context7.next = 15;
              return this._pc.setLocalDescription(offer);
            case 15:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context7.next = 19;
              return this._pc.setRemoteDescription(answer);
            case 19:
              this._mapMidTransceiver["delete"](localId);
            case 20:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function stopSending(_x4) {
        return _stopSending.apply(this, arguments);
      }
      return stopSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "pauseSending",
    value: function () {
      var _pauseSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('pauseSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context8.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
              _context8.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context8.sent;
              logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context8.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context8.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function pauseSending(_x5) {
        return _pauseSending.apply(this, arguments);
      }
      return pauseSending;
    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "resumeSending",
    value: function () {
      var _resumeSending = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(localId) {
        var transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('resumeSending() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context9.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              transceiver.direction = 'sendonly';
              this._remoteSdp.resumeSendingMediaSection(localId);
              _context9.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context9.sent;
              logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context9.next = 13;
              return this._pc.setLocalDescription(offer);
            case 13:
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context9.next = 17;
              return this._pc.setRemoteDescription(answer);
            case 17:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function resumeSending(_x6) {
        return _resumeSending.apply(this, arguments);
      }
      return resumeSending;
    }()
  }, {
    key: "replaceTrack",
    value: function () {
      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(localId, track) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertSendDirection();
              if (track) {
                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
              } else {
                logger.debug('replaceTrack() [localId:%s, no track]', localId);
              }
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context10.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              _context10.next = 7;
              return transceiver.sender.replaceTrack(track);
            case 7:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function replaceTrack(_x7, _x8) {
        return _replaceTrack.apply(this, arguments);
      }
      return replaceTrack;
    }()
  }, {
    key: "setMaxSpatialLayer",
    value: function () {
      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(localId, spatialLayer) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context11.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;
              });
              _context11.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function setMaxSpatialLayer(_x9, _x10) {
        return _setMaxSpatialLayer.apply(this, arguments);
      }
      return setMaxSpatialLayer;
    }()
  }, {
    key: "setRtpEncodingParameters",
    value: function () {
      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(localId, params) {
        var transceiver, parameters;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.assertSendDirection();
              logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context12.next = 5;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 5:
              parameters = transceiver.sender.getParameters();
              parameters.encodings.forEach(function (encoding, idx) {
                parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);
              });
              _context12.next = 9;
              return transceiver.sender.setParameters(parameters);
            case 9:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function setRtpEncodingParameters(_x11, _x12) {
        return _setRtpEncodingParameters.apply(this, arguments);
      }
      return setRtpEncodingParameters;
    }()
  }, {
    key: "getSenderStats",
    value: function () {
      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.assertSendDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context13.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context13.abrupt("return", transceiver.sender.getStats());
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getSenderStats(_x13) {
        return _getSenderStats.apply(this, arguments);
      }
      return getSenderStats;
    }()
  }, {
    key: "sendDataChannel",
    value: function () {
      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref3) {
        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, _a, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol;
              this.assertSendDirection();
              options = {
                negotiated: true,
                id: this._nextSendSctpStreamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('sendDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // Increase next id.
              this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
              // If this is the first DataChannel we need to create the SDP answer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context14.next = 24;
                break;
              }
              _context14.next = 9;
              return this._pc.createOffer();
            case 9:
              offer = _context14.sent;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find(function (m) {
                return m.type === 'application';
              });
              if (this._transportReady) {
                _context14.next = 15;
                break;
              }
              _context14.next = 15;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 15:
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              _context14.next = 18;
              return this._pc.setLocalDescription(offer);
            case 18:
              this._remoteSdp.sendSctpAssociation({
                offerMediaObject: offerMediaObject
              });
              answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context14.next = 23;
              return this._pc.setRemoteDescription(answer);
            case 23:
              this._hasDataChannelMediaSection = true;
            case 24:
              sctpStreamParameters = {
                streamId: options.id,
                ordered: options.ordered,
                maxPacketLifeTime: options.maxPacketLifeTime,
                maxRetransmits: options.maxRetransmits
              };
              return _context14.abrupt("return", {
                dataChannel: dataChannel,
                sctpStreamParameters: sctpStreamParameters
              });
            case 26:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function sendDataChannel(_x14) {
        return _sendDataChannel.apply(this, arguments);
      }
      return sendDataChannel;
    }()
  }, {
    key: "receive",
    value: function () {
      var _receive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(optionsList) {
        var _this3 = this;
        var _a, results, mapLocalId, _iterator2, _step2, options, trackId, kind, rtpParameters, streamId, localId, offer, answer, localSdpObject, _iterator3, _step3, _loop, _iterator4, _step4, _loop2;
        return _regeneratorRuntime().wrap(function _callee15$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              this.assertRecvDirection();
              results = [];
              mapLocalId = new Map();
              _iterator2 = _createForOfIteratorHelper(optionsList);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  options = _step2.value;
                  trackId = options.trackId, kind = options.kind, rtpParameters = options.rtpParameters, streamId = options.streamId;
                  logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
                  localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
                  mapLocalId.set(trackId, localId);
                  this._remoteSdp.receive({
                    mid: localId,
                    kind: kind,
                    offerRtpParameters: rtpParameters,
                    streamId: streamId || rtpParameters.rtcp.cname,
                    trackId: trackId
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context17.next = 9;
              return this._pc.setRemoteDescription(offer);
            case 9:
              _context17.next = 11;
              return this._pc.createAnswer();
            case 11:
              answer = _context17.sent;
              localSdpObject = sdpTransform.parse(answer.sdp);
              _iterator3 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 14;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var options, trackId, rtpParameters, localId, answerMediaObject;
                return _regeneratorRuntime().wrap(function _loop$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      options = _step3.value;
                      trackId = options.trackId, rtpParameters = options.rtpParameters;
                      localId = mapLocalId.get(trackId);
                      answerMediaObject = localSdpObject.media.find(function (m) {
                        return String(m.mid) === localId;
                      }); // May need to modify codec parameters in the answer based on codec
                      // parameters in the offer.
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject: answerMediaObject
                      });
                    case 5:
                    case "end":
                      return _context15.stop();
                  }
                }, _loop);
              });
              _iterator3.s();
            case 17:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 21;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 19);
            case 19:
              _context17.next = 17;
              break;
            case 21:
              _context17.next = 26;
              break;
            case 23:
              _context17.prev = 23;
              _context17.t1 = _context17["catch"](14);
              _iterator3.e(_context17.t1);
            case 26:
              _context17.prev = 26;
              _iterator3.f();
              return _context17.finish(26);
            case 29:
              answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject)
              };
              if (this._transportReady) {
                _context17.next = 33;
                break;
              }
              _context17.next = 33;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 33:
              logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context17.next = 36;
              return this._pc.setLocalDescription(answer);
            case 36:
              _iterator4 = _createForOfIteratorHelper(optionsList);
              _context17.prev = 37;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var options, trackId, localId, transceiver;
                return _regeneratorRuntime().wrap(function _loop2$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      options = _step4.value;
                      trackId = options.trackId;
                      localId = mapLocalId.get(trackId);
                      transceiver = _this3._pc.getTransceivers().find(function (t) {
                        return t.mid === localId;
                      });
                      if (transceiver) {
                        _context16.next = 6;
                        break;
                      }
                      throw new Error('new RTCRtpTransceiver not found');
                    case 6:
                      // Store in the map.
                      _this3._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId: localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    case 8:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop2);
              });
              _iterator4.s();
            case 40:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 44;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 42);
            case 42:
              _context17.next = 40;
              break;
            case 44:
              _context17.next = 49;
              break;
            case 46:
              _context17.prev = 46;
              _context17.t3 = _context17["catch"](37);
              _iterator4.e(_context17.t3);
            case 49:
              _context17.prev = 49;
              _iterator4.f();
              return _context17.finish(49);
            case 52:
              return _context17.abrupt("return", results);
            case 53:
            case "end":
              return _context17.stop();
          }
        }, _callee15, this, [[14, 23, 26, 29], [37, 46, 49, 52]]);
      }));
      function receive(_x15) {
        return _receive.apply(this, arguments);
      }
      return receive;
    }()
  }, {
    key: "stopReceiving",
    value: function () {
      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(localIds) {
        var _iterator5, _step5, localId, transceiver, offer, answer, _iterator6, _step6, _localId;
        return _regeneratorRuntime().wrap(function _callee16$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              this.assertRecvDirection();
              _iterator5 = _createForOfIteratorHelper(localIds);
              _context18.prev = 2;
              _iterator5.s();
            case 4:
              if ((_step5 = _iterator5.n()).done) {
                _context18.next = 13;
                break;
              }
              localId = _step5.value;
              logger.debug('stopReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context18.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              this._remoteSdp.closeMediaSection(transceiver.mid);
            case 11:
              _context18.next = 4;
              break;
            case 13:
              _context18.next = 18;
              break;
            case 15:
              _context18.prev = 15;
              _context18.t0 = _context18["catch"](2);
              _iterator5.e(_context18.t0);
            case 18:
              _context18.prev = 18;
              _iterator5.f();
              return _context18.finish(18);
            case 21:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context18.next = 25;
              return this._pc.setRemoteDescription(offer);
            case 25:
              _context18.next = 27;
              return this._pc.createAnswer();
            case 27:
              answer = _context18.sent;
              logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context18.next = 31;
              return this._pc.setLocalDescription(answer);
            case 31:
              _iterator6 = _createForOfIteratorHelper(localIds);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _localId = _step6.value;
                  this._mapMidTransceiver["delete"](_localId);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 33:
            case "end":
              return _context18.stop();
          }
        }, _callee16, this, [[2, 15, 18, 21]]);
      }));
      function stopReceiving(_x16) {
        return _stopReceiving.apply(this, arguments);
      }
      return stopReceiving;
    }()
  }, {
    key: "pauseReceiving",
    value: function () {
      var _pauseReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(localIds) {
        var _iterator7, _step7, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee17$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              this.assertRecvDirection();
              _iterator7 = _createForOfIteratorHelper(localIds);
              _context19.prev = 2;
              _iterator7.s();
            case 4:
              if ((_step7 = _iterator7.n()).done) {
                _context19.next = 14;
                break;
              }
              localId = _step7.value;
              logger.debug('pauseReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context19.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'inactive';
              this._remoteSdp.pauseMediaSection(localId);
            case 12:
              _context19.next = 4;
              break;
            case 14:
              _context19.next = 19;
              break;
            case 16:
              _context19.prev = 16;
              _context19.t0 = _context19["catch"](2);
              _iterator7.e(_context19.t0);
            case 19:
              _context19.prev = 19;
              _iterator7.f();
              return _context19.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context19.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context19.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context19.sent;
              logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context19.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context19.stop();
          }
        }, _callee17, this, [[2, 16, 19, 22]]);
      }));
      function pauseReceiving(_x17) {
        return _pauseReceiving.apply(this, arguments);
      }
      return pauseReceiving;
    }()
  }, {
    key: "resumeReceiving",
    value: function () {
      var _resumeReceiving = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(localIds) {
        var _iterator8, _step8, localId, transceiver, offer, answer;
        return _regeneratorRuntime().wrap(function _callee18$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              this.assertRecvDirection();
              _iterator8 = _createForOfIteratorHelper(localIds);
              _context20.prev = 2;
              _iterator8.s();
            case 4:
              if ((_step8 = _iterator8.n()).done) {
                _context20.next = 14;
                break;
              }
              localId = _step8.value;
              logger.debug('resumeReceiving() [localId:%s]', localId);
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context20.next = 10;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 10:
              transceiver.direction = 'recvonly';
              this._remoteSdp.resumeReceivingMediaSection(localId);
            case 12:
              _context20.next = 4;
              break;
            case 14:
              _context20.next = 19;
              break;
            case 16:
              _context20.prev = 16;
              _context20.t0 = _context20["catch"](2);
              _iterator8.e(_context20.t0);
            case 19:
              _context20.prev = 19;
              _iterator8.f();
              return _context20.finish(19);
            case 22:
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context20.next = 26;
              return this._pc.setRemoteDescription(offer);
            case 26:
              _context20.next = 28;
              return this._pc.createAnswer();
            case 28:
              answer = _context20.sent;
              logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
              _context20.next = 32;
              return this._pc.setLocalDescription(answer);
            case 32:
            case "end":
              return _context20.stop();
          }
        }, _callee18, this, [[2, 16, 19, 22]]);
      }));
      function resumeReceiving(_x18) {
        return _resumeReceiving.apply(this, arguments);
      }
      return resumeReceiving;
    }()
  }, {
    key: "getReceiverStats",
    value: function () {
      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(localId) {
        var transceiver;
        return _regeneratorRuntime().wrap(function _callee19$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.assertRecvDirection();
              transceiver = this._mapMidTransceiver.get(localId);
              if (transceiver) {
                _context21.next = 4;
                break;
              }
              throw new Error('associated RTCRtpTransceiver not found');
            case 4:
              return _context21.abrupt("return", transceiver.receiver.getStats());
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee19, this);
      }));
      function getReceiverStats(_x19) {
        return _getReceiverStats.apply(this, arguments);
      }
      return getReceiverStats;
    }()
  }, {
    key: "receiveDataChannel",
    value: function () {
      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref4) {
        var sctpStreamParameters, label, protocol, _a, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;
        return _regeneratorRuntime().wrap(function _callee20$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              sctpStreamParameters = _ref4.sctpStreamParameters, label = _ref4.label, protocol = _ref4.protocol;
              this.assertRecvDirection();
              streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;
              options = {
                negotiated: true,
                id: streamId,
                ordered: ordered,
                maxPacketLifeTime: maxPacketLifeTime,
                maxRetransmits: maxRetransmits,
                protocol: protocol
              };
              logger.debug('receiveDataChannel() [options:%o]', options);
              dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with
              // m=application section.
              if (this._hasDataChannelMediaSection) {
                _context22.next = 23;
                break;
              }
              this._remoteSdp.receiveSctpAssociation();
              offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp()
              };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              _context22.next = 12;
              return this._pc.setRemoteDescription(offer);
            case 12:
              _context22.next = 14;
              return this._pc.createAnswer();
            case 14:
              answer = _context22.sent;
              if (this._transportReady) {
                _context22.next = 19;
                break;
              }
              localSdpObject = sdpTransform.parse(answer.sdp);
              _context22.next = 19;
              return this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject: localSdpObject
              });
            case 19:
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              _context22.next = 22;
              return this._pc.setLocalDescription(answer);
            case 22:
              this._hasDataChannelMediaSection = true;
            case 23:
              return _context22.abrupt("return", {
                dataChannel: dataChannel
              });
            case 24:
            case "end":
              return _context22.stop();
          }
        }, _callee20, this);
      }));
      function receiveDataChannel(_x20) {
        return _receiveDataChannel.apply(this, arguments);
      }
      return receiveDataChannel;
    }()
  }, {
    key: "setupTransport",
    value: function () {
      var _setupTransport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref5) {
        var _this4 = this;
        var localDtlsRole, localSdpObject, dtlsParameters;
        return _regeneratorRuntime().wrap(function _callee21$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              localDtlsRole = _ref5.localDtlsRole, localSdpObject = _ref5.localSdpObject;
              if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
              // Get our local DTLS parameters.
              dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                sdpObject: localSdpObject
              }); // Set our DTLS role.
              dtlsParameters.role = localDtlsRole;
              // Update the remote DTLS role in the SDP.
              this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
              // Need to tell the remote transport about our parameters.
              _context23.next = 7;
              return new Promise(function (resolve, reject) {
                _this4.safeEmit('@connect', {
                  dtlsParameters: dtlsParameters
                }, resolve, reject);
              });
            case 7:
              this._transportReady = true;
            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee21, this);
      }));
      function setupTransport(_x21) {
        return _setupTransport.apply(this, arguments);
      }
      return setupTransport;
    }()
  }, {
    key: "assertSendDirection",
    value: function assertSendDirection() {
      if (this._direction !== 'send') {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
  }, {
    key: "assertRecvDirection",
    value: function assertRecvDirection() {
      if (this._direction !== 'recv') {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  }], [{
    key: "createFactory",
    value:
    /**
     * Creates a factory function.
     */
    function createFactory() {
      return function () {
        return new Safari12();
      };
    }
  }]);
  return Safari12;
}(HandlerInterface_1.HandlerInterface);
exports.Safari12 = Safari12;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.mangleRtpParameters = exports.getCapabilities = void 0;
var utils = __importStar(__webpack_require__(/*! ../../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */
function getCapabilities() {
  var nativeCaps = RTCRtpReceiver.getCapabilities();
  var caps = utils.clone(nativeCaps, {});
  var _iterator = _createForOfIteratorHelper(caps.codecs),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var codec = _step.value;
      // Rename numChannels to channels.
      codec.channels = codec.numChannels;
      delete codec.numChannels;
      // Add mimeType.
      codec.mimeType = codec.mimeType || "".concat(codec.kind, "/").concat(codec.name);
      // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
      if (codec.parameters) {
        var parameters = codec.parameters;
        if (parameters.apt) parameters.apt = Number(parameters.apt);
        if (parameters['packetization-mode']) parameters['packetization-mode'] = Number(parameters['packetization-mode']);
      }
      // Delete emty parameter String in rtcpFeedback.
      var _iterator2 = _createForOfIteratorHelper(codec.rtcpFeedback || []),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var feedback = _step2.value;
          if (!feedback.parameter) feedback.parameter = '';
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return caps;
}
exports.getCapabilities = getCapabilities;
/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */
function mangleRtpParameters(rtpParameters) {
  var params = utils.clone(rtpParameters, {});
  // Rename mid to muxId.
  if (params.mid) {
    params.muxId = params.mid;
    delete params.mid;
  }
  var _iterator3 = _createForOfIteratorHelper(params.codecs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var codec = _step3.value;
      // Rename channels to numChannels.
      if (codec.channels) {
        codec.numChannels = codec.channels;
        delete codec.channels;
      }
      // Add codec.name (requried by Edge).
      if (codec.mimeType && !codec.name) codec.name = codec.mimeType.split('/')[1];
      // Remove mimeType.
      delete codec.mimeType;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return params;
}
exports.mangleRtpParameters = mangleRtpParameters;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
var utils = __importStar(__webpack_require__(/*! ../../utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var MediaSection = /*#__PURE__*/function () {
  function MediaSection(_ref) {
    var iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      _ref$planB = _ref.planB,
      planB = _ref$planB === void 0 ? false : _ref$planB;
    _classCallCheck(this, MediaSection);
    this._mediaObject = {};
    this._planB = planB;
    if (iceParameters) {
      this.setIceParameters(iceParameters);
    }
    if (iceCandidates) {
      this._mediaObject.candidates = [];
      var _iterator = _createForOfIteratorHelper(iceCandidates),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var candidate = _step.value;
          var candidateObject = {};
          // mediasoup does mandates rtcp-mux so candidates component is always
          // RTP (1).
          candidateObject.component = 1;
          candidateObject.foundation = candidate.foundation;
          candidateObject.ip = candidate.ip;
          candidateObject.port = candidate.port;
          candidateObject.priority = candidate.priority;
          candidateObject.transport = candidate.protocol;
          candidateObject.type = candidate.type;
          if (candidate.tcpType) candidateObject.tcptype = candidate.tcpType;
          this._mediaObject.candidates.push(candidateObject);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this._mediaObject.endOfCandidates = 'end-of-candidates';
      this._mediaObject.iceOptions = 'renomination';
    }
    if (dtlsParameters) {
      this.setDtlsRole(dtlsParameters.role);
    }
  }
  _createClass(MediaSection, [{
    key: "mid",
    get: function get() {
      return String(this._mediaObject.mid);
    }
  }, {
    key: "closed",
    get: function get() {
      return this._mediaObject.port === 0;
    }
  }, {
    key: "getObject",
    value: function getObject() {
      return this._mediaObject;
    }
  }, {
    key: "setIceParameters",
    value: function setIceParameters(iceParameters) {
      this._mediaObject.iceUfrag = iceParameters.usernameFragment;
      this._mediaObject.icePwd = iceParameters.password;
    }
  }, {
    key: "pause",
    value: function pause() {
      this._mediaObject.direction = 'inactive';
    }
  }, {
    key: "disable",
    value: function disable() {
      this.pause();
      delete this._mediaObject.ext;
      delete this._mediaObject.ssrcs;
      delete this._mediaObject.ssrcGroups;
      delete this._mediaObject.simulcast;
      delete this._mediaObject.simulcast_03;
      delete this._mediaObject.rids;
      delete this._mediaObject.extmapAllowMixed;
    }
  }, {
    key: "close",
    value: function close() {
      this.disable();
      this._mediaObject.port = 0;
    }
  }]);
  return MediaSection;
}();
exports.MediaSection = MediaSection;
var AnswerMediaSection = /*#__PURE__*/function (_MediaSection) {
  _inherits(AnswerMediaSection, _MediaSection);
  var _super = _createSuper(AnswerMediaSection);
  function AnswerMediaSection(_ref2) {
    var _this;
    var iceParameters = _ref2.iceParameters,
      iceCandidates = _ref2.iceCandidates,
      dtlsParameters = _ref2.dtlsParameters,
      sctpParameters = _ref2.sctpParameters,
      plainRtpParameters = _ref2.plainRtpParameters,
      _ref2$planB = _ref2.planB,
      planB = _ref2$planB === void 0 ? false : _ref2$planB,
      offerMediaObject = _ref2.offerMediaObject,
      offerRtpParameters = _ref2.offerRtpParameters,
      answerRtpParameters = _ref2.answerRtpParameters,
      codecOptions = _ref2.codecOptions,
      _ref2$extmapAllowMixe = _ref2.extmapAllowMixed,
      extmapAllowMixed = _ref2$extmapAllowMixe === void 0 ? false : _ref2$extmapAllowMixe;
    _classCallCheck(this, AnswerMediaSection);
    _this = _super.call(this, {
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      planB: planB
    });
    _this._mediaObject.mid = String(offerMediaObject.mid);
    _this._mediaObject.type = offerMediaObject.type;
    _this._mediaObject.protocol = offerMediaObject.protocol;
    if (!plainRtpParameters) {
      _this._mediaObject.connection = {
        ip: '127.0.0.1',
        version: 4
      };
      _this._mediaObject.port = 7;
    } else {
      _this._mediaObject.connection = {
        ip: plainRtpParameters.ip,
        version: plainRtpParameters.ipVersion
      };
      _this._mediaObject.port = plainRtpParameters.port;
    }
    switch (offerMediaObject.type) {
      case 'audio':
      case 'video':
        {
          _this._mediaObject.direction = 'recvonly';
          _this._mediaObject.rtp = [];
          _this._mediaObject.rtcpFb = [];
          _this._mediaObject.fmtp = [];
          var _iterator2 = _createForOfIteratorHelper(answerRtpParameters.codecs),
            _step2;
          try {
            var _loop = function _loop() {
              var codec = _step2.value;
              var rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) rtp.encoding = codec.channels;
              _this._mediaObject.rtp.push(rtp);
              var codecParameters = utils.clone(codec.parameters, {});
              if (codecOptions) {
                var opusStereo = codecOptions.opusStereo,
                  opusFec = codecOptions.opusFec,
                  opusDtx = codecOptions.opusDtx,
                  opusMaxPlaybackRate = codecOptions.opusMaxPlaybackRate,
                  opusMaxAverageBitrate = codecOptions.opusMaxAverageBitrate,
                  opusPtime = codecOptions.opusPtime,
                  videoGoogleStartBitrate = codecOptions.videoGoogleStartBitrate,
                  videoGoogleMaxBitrate = codecOptions.videoGoogleMaxBitrate,
                  videoGoogleMinBitrate = codecOptions.videoGoogleMinBitrate;
                var offerCodec = offerRtpParameters.codecs.find(function (c) {
                  return c.payloadType === codec.payloadType;
                });
                switch (codec.mimeType.toLowerCase()) {
                  case 'audio/opus':
                    {
                      if (opusStereo !== undefined) {
                        offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                        codecParameters.stereo = opusStereo ? 1 : 0;
                      }
                      if (opusFec !== undefined) {
                        offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                        codecParameters.useinbandfec = opusFec ? 1 : 0;
                      }
                      if (opusDtx !== undefined) {
                        offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                        codecParameters.usedtx = opusDtx ? 1 : 0;
                      }
                      if (opusMaxPlaybackRate !== undefined) {
                        codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                      }
                      if (opusMaxAverageBitrate !== undefined) {
                        codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                      }
                      if (opusPtime !== undefined) {
                        offerCodec.parameters.ptime = opusPtime;
                        codecParameters.ptime = opusPtime;
                      }
                      break;
                    }
                  case 'video/vp8':
                  case 'video/vp9':
                  case 'video/h264':
                  case 'video/h265':
                    {
                      if (videoGoogleStartBitrate !== undefined) codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;
                      if (videoGoogleMaxBitrate !== undefined) codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;
                      if (videoGoogleMinBitrate !== undefined) codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;
                      break;
                    }
                }
              }
              var fmtp = {
                payload: codec.payloadType,
                config: ''
              };
              for (var _i = 0, _Object$keys = Object.keys(codecParameters); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                if (fmtp.config) fmtp.config += ';';
                fmtp.config += "".concat(key, "=").concat(codecParameters[key]);
              }
              if (fmtp.config) _this._mediaObject.fmtp.push(fmtp);
              var _iterator6 = _createForOfIteratorHelper(codec.rtcpFeedback),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var fb = _step6.value;
                  _this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          _this._mediaObject.payloads = answerRtpParameters.codecs.map(function (codec) {
            return codec.payloadType;
          }).join(' ');
          _this._mediaObject.ext = [];
          var _iterator3 = _createForOfIteratorHelper(answerRtpParameters.headerExtensions),
            _step3;
          try {
            var _loop2 = function _loop2() {
              var ext = _step3.value;
              // Don't add a header extension if not present in the offer.
              var found = (offerMediaObject.ext || []).some(function (localExt) {
                return localExt.uri === ext.uri;
              });
              if (!found) return 1; // continue
              _this._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            };
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              if (_loop2()) continue;
            }
            // Allow both 1 byte and 2 bytes length header extensions.
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          if (extmapAllowMixed && offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
            _this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
          }
          // Simulcast.
          if (offerMediaObject.simulcast) {
            _this._mediaObject.simulcast = {
              dir1: 'recv',
              list1: offerMediaObject.simulcast.list1
            };
            _this._mediaObject.rids = [];
            var _iterator4 = _createForOfIteratorHelper(offerMediaObject.rids || []),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var rid = _step4.value;
                if (rid.direction !== 'send') continue;
                _this._mediaObject.rids.push({
                  id: rid.id,
                  direction: 'recv'
                });
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
          // Simulcast (draft version 03).
          else if (offerMediaObject.simulcast_03) {
            // eslint-disable-next-line camelcase
            _this._mediaObject.simulcast_03 = {
              value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')
            };
            _this._mediaObject.rids = [];
            var _iterator5 = _createForOfIteratorHelper(offerMediaObject.rids || []),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _rid = _step5.value;
                if (_rid.direction !== 'send') continue;
                _this._mediaObject.rids.push({
                  id: _rid.id,
                  direction: 'recv'
                });
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
          _this._mediaObject.rtcpMux = 'rtcp-mux';
          _this._mediaObject.rtcpRsize = 'rtcp-rsize';
          if (_this._planB && _this._mediaObject.type === 'video') _this._mediaObject.xGoogleFlag = 'conference';
          break;
        }
      case 'application':
        {
          // New spec.
          if (typeof offerMediaObject.sctpPort === 'number') {
            _this._mediaObject.payloads = 'webrtc-datachannel';
            _this._mediaObject.sctpPort = sctpParameters.port;
            _this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          }
          // Old spec.
          else if (offerMediaObject.sctpmap) {
            _this._mediaObject.payloads = sctpParameters.port;
            _this._mediaObject.sctpmap = {
              app: 'webrtc-datachannel',
              sctpmapNumber: sctpParameters.port,
              maxMessageSize: sctpParameters.maxMessageSize
            };
          }
          break;
        }
    }
    return _this;
  }
  _createClass(AnswerMediaSection, [{
    key: "setDtlsRole",
    value: function setDtlsRole(role) {
      switch (role) {
        case 'client':
          this._mediaObject.setup = 'active';
          break;
        case 'server':
          this._mediaObject.setup = 'passive';
          break;
        case 'auto':
          this._mediaObject.setup = 'actpass';
          break;
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this._mediaObject.direction = 'recvonly';
    }
  }]);
  return AnswerMediaSection;
}(MediaSection);
exports.AnswerMediaSection = AnswerMediaSection;
var OfferMediaSection = /*#__PURE__*/function (_MediaSection2) {
  _inherits(OfferMediaSection, _MediaSection2);
  var _super2 = _createSuper(OfferMediaSection);
  function OfferMediaSection(_ref3) {
    var _this2;
    var iceParameters = _ref3.iceParameters,
      iceCandidates = _ref3.iceCandidates,
      dtlsParameters = _ref3.dtlsParameters,
      sctpParameters = _ref3.sctpParameters,
      plainRtpParameters = _ref3.plainRtpParameters,
      _ref3$planB = _ref3.planB,
      planB = _ref3$planB === void 0 ? false : _ref3$planB,
      mid = _ref3.mid,
      kind = _ref3.kind,
      offerRtpParameters = _ref3.offerRtpParameters,
      streamId = _ref3.streamId,
      trackId = _ref3.trackId,
      _ref3$oldDataChannelS = _ref3.oldDataChannelSpec,
      oldDataChannelSpec = _ref3$oldDataChannelS === void 0 ? false : _ref3$oldDataChannelS;
    _classCallCheck(this, OfferMediaSection);
    _this2 = _super2.call(this, {
      iceParameters: iceParameters,
      iceCandidates: iceCandidates,
      dtlsParameters: dtlsParameters,
      planB: planB
    });
    _this2._mediaObject.mid = String(mid);
    _this2._mediaObject.type = kind;
    if (!plainRtpParameters) {
      _this2._mediaObject.connection = {
        ip: '127.0.0.1',
        version: 4
      };
      if (!sctpParameters) _this2._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';else _this2._mediaObject.protocol = 'UDP/DTLS/SCTP';
      _this2._mediaObject.port = 7;
    } else {
      _this2._mediaObject.connection = {
        ip: plainRtpParameters.ip,
        version: plainRtpParameters.ipVersion
      };
      _this2._mediaObject.protocol = 'RTP/AVP';
      _this2._mediaObject.port = plainRtpParameters.port;
    }
    switch (kind) {
      case 'audio':
      case 'video':
        {
          _this2._mediaObject.direction = 'sendonly';
          _this2._mediaObject.rtp = [];
          _this2._mediaObject.rtcpFb = [];
          _this2._mediaObject.fmtp = [];
          if (!_this2._planB) _this2._mediaObject.msid = "".concat(streamId || '-', " ").concat(trackId);
          var _iterator7 = _createForOfIteratorHelper(offerRtpParameters.codecs),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var codec = _step7.value;
              var rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) rtp.encoding = codec.channels;
              _this2._mediaObject.rtp.push(rtp);
              var fmtp = {
                payload: codec.payloadType,
                config: ''
              };
              for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {
                var key = _Object$keys2[_i2];
                if (fmtp.config) fmtp.config += ';';
                fmtp.config += "".concat(key, "=").concat(codec.parameters[key]);
              }
              if (fmtp.config) _this2._mediaObject.fmtp.push(fmtp);
              var _iterator9 = _createForOfIteratorHelper(codec.rtcpFeedback),
                _step9;
              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var fb = _step9.value;
                  _this2._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          _this2._mediaObject.payloads = offerRtpParameters.codecs.map(function (codec) {
            return codec.payloadType;
          }).join(' ');
          _this2._mediaObject.ext = [];
          var _iterator8 = _createForOfIteratorHelper(offerRtpParameters.headerExtensions),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var ext = _step8.value;
              _this2._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
          _this2._mediaObject.rtcpMux = 'rtcp-mux';
          _this2._mediaObject.rtcpRsize = 'rtcp-rsize';
          var encoding = offerRtpParameters.encodings[0];
          var ssrc = encoding.ssrc;
          var rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
          _this2._mediaObject.ssrcs = [];
          _this2._mediaObject.ssrcGroups = [];
          if (offerRtpParameters.rtcp.cname) {
            _this2._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'cname',
              value: offerRtpParameters.rtcp.cname
            });
          }
          if (_this2._planB) {
            _this2._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'msid',
              value: "".concat(streamId || '-', " ").concat(trackId)
            });
          }
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              _this2._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'cname',
                value: offerRtpParameters.rtcp.cname
              });
            }
            if (_this2._planB) {
              _this2._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'msid',
                value: "".concat(streamId || '-', " ").concat(trackId)
              });
            }
            // Associate original and retransmission SSRCs.
            _this2._mediaObject.ssrcGroups.push({
              semantics: 'FID',
              ssrcs: "".concat(ssrc, " ").concat(rtxSsrc)
            });
          }
          break;
        }
      case 'application':
        {
          // New spec.
          if (!oldDataChannelSpec) {
            _this2._mediaObject.payloads = 'webrtc-datachannel';
            _this2._mediaObject.sctpPort = sctpParameters.port;
            _this2._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          }
          // Old spec.
          else {
            _this2._mediaObject.payloads = sctpParameters.port;
            _this2._mediaObject.sctpmap = {
              app: 'webrtc-datachannel',
              sctpmapNumber: sctpParameters.port,
              maxMessageSize: sctpParameters.maxMessageSize
            };
          }
          break;
        }
    }
    return _this2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createClass(OfferMediaSection, [{
    key: "setDtlsRole",
    value: function setDtlsRole(role) {
      // Always 'actpass'.
      this._mediaObject.setup = 'actpass';
    }
  }, {
    key: "resume",
    value: function resume() {
      this._mediaObject.direction = 'sendonly';
    }
  }, {
    key: "planBReceive",
    value: function planBReceive(_ref4) {
      var _this3 = this;
      var offerRtpParameters = _ref4.offerRtpParameters,
        streamId = _ref4.streamId,
        trackId = _ref4.trackId;
      var encoding = offerRtpParameters.encodings[0];
      var ssrc = encoding.ssrc;
      var rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
      var payloads = this._mediaObject.payloads.split(' ');
      var _iterator10 = _createForOfIteratorHelper(offerRtpParameters.codecs),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var codec = _step10.value;
          if (payloads.includes(String(codec.payloadType))) {
            continue;
          }
          var rtp = {
            payload: codec.payloadType,
            codec: getCodecName(codec),
            rate: codec.clockRate
          };
          if (codec.channels > 1) rtp.encoding = codec.channels;
          this._mediaObject.rtp.push(rtp);
          var fmtp = {
            payload: codec.payloadType,
            config: ''
          };
          for (var _i3 = 0, _Object$keys3 = Object.keys(codec.parameters); _i3 < _Object$keys3.length; _i3++) {
            var key = _Object$keys3[_i3];
            if (fmtp.config) fmtp.config += ';';
            fmtp.config += "".concat(key, "=").concat(codec.parameters[key]);
          }
          if (fmtp.config) this._mediaObject.fmtp.push(fmtp);
          var _iterator11 = _createForOfIteratorHelper(codec.rtcpFeedback),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var fb = _step11.value;
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      this._mediaObject.payloads += " ".concat(offerRtpParameters.codecs.filter(function (codec) {
        return !_this3._mediaObject.payloads.includes(codec.payloadType);
      }).map(function (codec) {
        return codec.payloadType;
      }).join(' '));
      this._mediaObject.payloads = this._mediaObject.payloads.trim();
      if (offerRtpParameters.rtcp.cname) {
        this._mediaObject.ssrcs.push({
          id: ssrc,
          attribute: 'cname',
          value: offerRtpParameters.rtcp.cname
        });
      }
      this._mediaObject.ssrcs.push({
        id: ssrc,
        attribute: 'msid',
        value: "".concat(streamId || '-', " ").concat(trackId)
      });
      if (rtxSsrc) {
        if (offerRtpParameters.rtcp.cname) {
          this._mediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: offerRtpParameters.rtcp.cname
          });
        }
        this._mediaObject.ssrcs.push({
          id: rtxSsrc,
          attribute: 'msid',
          value: "".concat(streamId || '-', " ").concat(trackId)
        });
        // Associate original and retransmission SSRCs.
        this._mediaObject.ssrcGroups.push({
          semantics: 'FID',
          ssrcs: "".concat(ssrc, " ").concat(rtxSsrc)
        });
      }
    }
  }, {
    key: "planBStopReceiving",
    value: function planBStopReceiving(_ref5) {
      var offerRtpParameters = _ref5.offerRtpParameters;
      var encoding = offerRtpParameters.encodings[0];
      var ssrc = encoding.ssrc;
      var rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
      this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter(function (s) {
        return s.id !== ssrc && s.id !== rtxSsrc;
      });
      if (rtxSsrc) {
        this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter(function (group) {
          return group.ssrcs !== "".concat(ssrc, " ").concat(rtxSsrc);
        });
      }
    }
  }]);
  return OfferMediaSection;
}(MediaSection);
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType');
  return mimeTypeMatch[2];
}

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RemoteSdp = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
var Logger_1 = __webpack_require__(/*! ../../Logger */ "./node_modules/mediasoup-client/lib/Logger.js");
var MediaSection_1 = __webpack_require__(/*! ./MediaSection */ "./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js");
var logger = new Logger_1.Logger('RemoteSdp');
var RemoteSdp = /*#__PURE__*/function () {
  function RemoteSdp(_ref) {
    var iceParameters = _ref.iceParameters,
      iceCandidates = _ref.iceCandidates,
      dtlsParameters = _ref.dtlsParameters,
      sctpParameters = _ref.sctpParameters,
      plainRtpParameters = _ref.plainRtpParameters,
      _ref$planB = _ref.planB,
      planB = _ref$planB === void 0 ? false : _ref$planB;
    _classCallCheck(this, RemoteSdp);
    // MediaSection instances with same order as in the SDP.
    this._mediaSections = [];
    // MediaSection indices indexed by MID.
    this._midToIndex = new Map();
    this._iceParameters = iceParameters;
    this._iceCandidates = iceCandidates;
    this._dtlsParameters = dtlsParameters;
    this._sctpParameters = sctpParameters;
    this._plainRtpParameters = plainRtpParameters;
    this._planB = planB;
    this._sdpObject = {
      version: 0,
      origin: {
        address: '0.0.0.0',
        ipVer: 4,
        netType: 'IN',
        sessionId: 10000,
        sessionVersion: 0,
        username: 'mediasoup-client'
      },
      name: '-',
      timing: {
        start: 0,
        stop: 0
      },
      media: []
    };
    // If ICE parameters are given, add ICE-Lite indicator.
    if (iceParameters && iceParameters.iceLite) {
      this._sdpObject.icelite = 'ice-lite';
    }
    // If DTLS parameters are given, assume WebRTC and BUNDLE.
    if (dtlsParameters) {
      this._sdpObject.msidSemantic = {
        semantic: 'WMS',
        token: '*'
      };
      // NOTE: We take the latest fingerprint.
      var numFingerprints = this._dtlsParameters.fingerprints.length;
      this._sdpObject.fingerprint = {
        type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
        hash: dtlsParameters.fingerprints[numFingerprints - 1].value
      };
      this._sdpObject.groups = [{
        type: 'BUNDLE',
        mids: ''
      }];
    }
    // If there are plain RPT parameters, override SDP origin.
    if (plainRtpParameters) {
      this._sdpObject.origin.address = plainRtpParameters.ip;
      this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
    }
  }
  _createClass(RemoteSdp, [{
    key: "updateIceParameters",
    value: function updateIceParameters(iceParameters) {
      logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
      this._iceParameters = iceParameters;
      this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
      var _iterator = _createForOfIteratorHelper(this._mediaSections),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var mediaSection = _step.value;
          mediaSection.setIceParameters(iceParameters);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "updateDtlsRole",
    value: function updateDtlsRole(role) {
      logger.debug('updateDtlsRole() [role:%s]', role);
      this._dtlsParameters.role = role;
      var _iterator2 = _createForOfIteratorHelper(this._mediaSections),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var mediaSection = _step2.value;
          mediaSection.setDtlsRole(role);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "getNextMediaSectionIdx",
    value: function getNextMediaSectionIdx() {
      // If a closed media section is found, return its index.
      for (var idx = 0; idx < this._mediaSections.length; ++idx) {
        var mediaSection = this._mediaSections[idx];
        if (mediaSection.closed) return {
          idx: idx,
          reuseMid: mediaSection.mid
        };
      }
      // If no closed media section is found, return next one.
      return {
        idx: this._mediaSections.length
      };
    }
  }, {
    key: "send",
    value: function send(_ref2) {
      var offerMediaObject = _ref2.offerMediaObject,
        reuseMid = _ref2.reuseMid,
        offerRtpParameters = _ref2.offerRtpParameters,
        answerRtpParameters = _ref2.answerRtpParameters,
        codecOptions = _ref2.codecOptions,
        _ref2$extmapAllowMixe = _ref2.extmapAllowMixed,
        extmapAllowMixed = _ref2$extmapAllowMixe === void 0 ? false : _ref2$extmapAllowMixe;
      var mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        plainRtpParameters: this._plainRtpParameters,
        planB: this._planB,
        offerMediaObject: offerMediaObject,
        offerRtpParameters: offerRtpParameters,
        answerRtpParameters: answerRtpParameters,
        codecOptions: codecOptions,
        extmapAllowMixed: extmapAllowMixed
      });
      // Unified-Plan with closed media section replacement.
      if (reuseMid) {
        this._replaceMediaSection(mediaSection, reuseMid);
      }
      // Unified-Plan or Plan-B with different media kind.
      else if (!this._midToIndex.has(mediaSection.mid)) {
        this._addMediaSection(mediaSection);
      }
      // Plan-B with same media kind.
      else {
        this._replaceMediaSection(mediaSection);
      }
    }
  }, {
    key: "receive",
    value: function receive(_ref3) {
      var mid = _ref3.mid,
        kind = _ref3.kind,
        offerRtpParameters = _ref3.offerRtpParameters,
        streamId = _ref3.streamId,
        trackId = _ref3.trackId;
      var idx = this._midToIndex.get(mid);
      var mediaSection;
      if (idx !== undefined) mediaSection = this._mediaSections[idx];
      // Unified-Plan or different media kind.
      if (!mediaSection) {
        mediaSection = new MediaSection_1.OfferMediaSection({
          iceParameters: this._iceParameters,
          iceCandidates: this._iceCandidates,
          dtlsParameters: this._dtlsParameters,
          plainRtpParameters: this._plainRtpParameters,
          planB: this._planB,
          mid: mid,
          kind: kind,
          offerRtpParameters: offerRtpParameters,
          streamId: streamId,
          trackId: trackId
        });
        // Let's try to recycle a closed media section (if any).
        // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
        var oldMediaSection = this._mediaSections.find(function (m) {
          return m.closed;
        });
        if (oldMediaSection) {
          this._replaceMediaSection(mediaSection, oldMediaSection.mid);
        } else {
          this._addMediaSection(mediaSection);
        }
      }
      // Plan-B.
      else {
        mediaSection.planBReceive({
          offerRtpParameters: offerRtpParameters,
          streamId: streamId,
          trackId: trackId
        });
        this._replaceMediaSection(mediaSection);
      }
    }
  }, {
    key: "pauseMediaSection",
    value: function pauseMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.pause();
    }
  }, {
    key: "resumeSendingMediaSection",
    value: function resumeSendingMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
  }, {
    key: "resumeReceivingMediaSection",
    value: function resumeReceivingMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
  }, {
    key: "disableMediaSection",
    value: function disableMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
  }, {
    key: "closeMediaSection",
    value: function closeMediaSection(mid) {
      var mediaSection = this._findMediaSection(mid);
      // NOTE: Closing the first m section is a pain since it invalidates the
      // bundled transport, so let's avoid it.
      if (mid === this._firstMid) {
        logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
        this.disableMediaSection(mid);
        return false;
      }
      mediaSection.close();
      // Regenerate BUNDLE mids.
      this._regenerateBundleMids();
      return true;
    }
  }, {
    key: "planBStopReceiving",
    value: function planBStopReceiving(_ref4) {
      var mid = _ref4.mid,
        offerRtpParameters = _ref4.offerRtpParameters;
      var idx = this._midToIndex.get(mid);
      if (idx === undefined) {
        throw new Error("no media section found with mid '".concat(mid, "'"));
      }
      var mediaSection = this._mediaSections[idx];
      mediaSection.planBStopReceiving({
        offerRtpParameters: offerRtpParameters
      });
      this._replaceMediaSection(mediaSection);
    }
  }, {
    key: "sendSctpAssociation",
    value: function sendSctpAssociation(_ref5) {
      var offerMediaObject = _ref5.offerMediaObject;
      var mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        offerMediaObject: offerMediaObject
      });
      this._addMediaSection(mediaSection);
    }
  }, {
    key: "receiveSctpAssociation",
    value: function receiveSctpAssociation() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$oldDataChannelS = _ref6.oldDataChannelSpec,
        oldDataChannelSpec = _ref6$oldDataChannelS === void 0 ? false : _ref6$oldDataChannelS;
      var mediaSection = new MediaSection_1.OfferMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        mid: 'datachannel',
        kind: 'application',
        oldDataChannelSpec: oldDataChannelSpec
      });
      this._addMediaSection(mediaSection);
    }
  }, {
    key: "getSdp",
    value: function getSdp() {
      // Increase SDP version.
      this._sdpObject.origin.sessionVersion++;
      return sdpTransform.write(this._sdpObject);
    }
  }, {
    key: "_addMediaSection",
    value: function _addMediaSection(newMediaSection) {
      if (!this._firstMid) this._firstMid = newMediaSection.mid;
      // Add to the vector.
      this._mediaSections.push(newMediaSection);
      // Add to the map.
      this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
      // Add to the SDP object.
      this._sdpObject.media.push(newMediaSection.getObject());
      // Regenerate BUNDLE mids.
      this._regenerateBundleMids();
    }
  }, {
    key: "_replaceMediaSection",
    value: function _replaceMediaSection(newMediaSection, reuseMid) {
      // Store it in the map.
      if (typeof reuseMid === 'string') {
        var idx = this._midToIndex.get(reuseMid);
        if (idx === undefined) {
          throw new Error("no media section found for reuseMid '".concat(reuseMid, "'"));
        }
        var oldMediaSection = this._mediaSections[idx];
        // Replace the index in the vector with the new media section.
        this._mediaSections[idx] = newMediaSection;
        // Update the map.
        this._midToIndex["delete"](oldMediaSection.mid);
        this._midToIndex.set(newMediaSection.mid, idx);
        // Update the SDP object.
        this._sdpObject.media[idx] = newMediaSection.getObject();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
      } else {
        var _idx = this._midToIndex.get(newMediaSection.mid);
        if (_idx === undefined) {
          throw new Error("no media section found with mid '".concat(newMediaSection.mid, "'"));
        }
        // Replace the index in the vector with the new media section.
        this._mediaSections[_idx] = newMediaSection;
        // Update the SDP object.
        this._sdpObject.media[_idx] = newMediaSection.getObject();
      }
    }
  }, {
    key: "_findMediaSection",
    value: function _findMediaSection(mid) {
      var idx = this._midToIndex.get(mid);
      if (idx === undefined) {
        throw new Error("no media section found with mid '".concat(mid, "'"));
      }
      return this._mediaSections[idx];
    }
  }, {
    key: "_regenerateBundleMids",
    value: function _regenerateBundleMids() {
      if (!this._dtlsParameters) return;
      this._sdpObject.groups[0].mids = this._mediaSections.filter(function (mediaSection) {
        return !mediaSection.closed;
      }).map(function (mediaSection) {
        return mediaSection.mid;
      }).join(' ');
    }
  }]);
  return RemoteSdp;
}();
exports.RemoteSdp = RemoteSdp;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;
var sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ "./node_modules/sdp-transform/lib/index.js"));
function extractRtpCapabilities(_ref) {
  var sdpObject = _ref.sdpObject;
  // Map of RtpCodecParameters indexed by payload type.
  var codecsMap = new Map();
  // Array of RtpHeaderExtensions.
  var headerExtensions = [];
  // Whether a m=audio/video section has been already found.
  var gotAudio = false;
  var gotVideo = false;
  var _iterator = _createForOfIteratorHelper(sdpObject.media),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var m = _step.value;
      var kind = m.type;
      switch (kind) {
        case 'audio':
          {
            if (gotAudio) continue;
            gotAudio = true;
            break;
          }
        case 'video':
          {
            if (gotVideo) continue;
            gotVideo = true;
            break;
          }
        default:
          {
            continue;
          }
      }
      // Get codecs.
      var _iterator2 = _createForOfIteratorHelper(m.rtp),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rtp = _step2.value;
          var codec = {
            kind: kind,
            mimeType: "".concat(kind, "/").concat(rtp.codec),
            preferredPayloadType: rtp.payload,
            clockRate: rtp.rate,
            channels: rtp.encoding,
            parameters: {},
            rtcpFeedback: []
          };
          codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(m.fmtp || []),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var fmtp = _step3.value;
          var parameters = sdpTransform.parseParams(fmtp.config);
          var _codec = codecsMap.get(fmtp.payload);
          if (!_codec) continue;
          // Specials case to convert parameter value to string.
          if (parameters && parameters.hasOwnProperty('profile-level-id')) parameters['profile-level-id'] = String(parameters['profile-level-id']);
          _codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var _iterator4 = _createForOfIteratorHelper(m.rtcpFb || []),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var fb = _step4.value;
          var _codec2 = codecsMap.get(fb.payload);
          if (!_codec2) continue;
          var feedback = {
            type: fb.type,
            parameter: fb.subtype
          };
          if (!feedback.parameter) delete feedback.parameter;
          _codec2.rtcpFeedback.push(feedback);
        }
        // Get RTP header extensions.
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      var _iterator5 = _createForOfIteratorHelper(m.ext || []),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ext = _step5.value;
          // Ignore encrypted extensions (not yet supported in mediasoup).
          if (ext['encrypt-uri']) continue;
          var headerExtension = {
            kind: kind,
            uri: ext.uri,
            preferredId: ext.value
          };
          headerExtensions.push(headerExtension);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var rtpCapabilities = {
    codecs: Array.from(codecsMap.values()),
    headerExtensions: headerExtensions
  };
  return rtpCapabilities;
}
exports.extractRtpCapabilities = extractRtpCapabilities;
function extractDtlsParameters(_ref2) {
  var sdpObject = _ref2.sdpObject;
  var mediaObject = (sdpObject.media || []).find(function (m) {
    return m.iceUfrag && m.port !== 0;
  });
  if (!mediaObject) throw new Error('no active media section found');
  var fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;
  var role;
  switch (mediaObject.setup) {
    case 'active':
      role = 'client';
      break;
    case 'passive':
      role = 'server';
      break;
    case 'actpass':
      role = 'auto';
      break;
  }
  var dtlsParameters = {
    role: role,
    fingerprints: [{
      algorithm: fingerprint.type,
      value: fingerprint.hash
    }]
  };
  return dtlsParameters;
}
exports.extractDtlsParameters = extractDtlsParameters;
function getCname(_ref3) {
  var offerMediaObject = _ref3.offerMediaObject;
  var ssrcCnameLine = (offerMediaObject.ssrcs || []).find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) return '';
  return ssrcCnameLine.value;
}
exports.getCname = getCname;
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters(_ref4) {
  var offerRtpParameters = _ref4.offerRtpParameters,
    answerMediaObject = _ref4.answerMediaObject;
  var _iterator6 = _createForOfIteratorHelper(offerRtpParameters.codecs),
    _step6;
  try {
    var _loop = function _loop() {
        var codec = _step6.value;
        var mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus') return 0; // continue
        var rtp = (answerMediaObject.rtp || []).find(function (r) {
          return r.payload === codec.payloadType;
        });
        if (!rtp) return 0; // continue
        // Just in case.
        answerMediaObject.fmtp = answerMediaObject.fmtp || [];
        var fmtp = answerMediaObject.fmtp.find(function (f) {
          return f.payload === codec.payloadType;
        });
        if (!fmtp) {
          fmtp = {
            payload: codec.payloadType,
            config: ''
          };
          answerMediaObject.fmtp.push(fmtp);
        }
        var parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
          case 'audio/opus':
            {
              var spropStereo = codec.parameters['sprop-stereo'];
              if (spropStereo !== undefined) parameters.stereo = spropStereo ? 1 : 0;
              break;
            }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          if (fmtp.config) fmtp.config += ';';
          fmtp.config += "".concat(key, "=").concat(parameters[key]);
        }
      },
      _ret;
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
}
exports.applyCodecParameters = applyCodecParameters;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
function getRtpEncodings(_ref) {
  var offerMediaObject = _ref.offerMediaObject,
    track = _ref.track;
  // First media SSRC (or the only one).
  var firstSsrc;
  var ssrcs = new Set();
  var _iterator = _createForOfIteratorHelper(offerMediaObject.ssrcs || []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      if (line.attribute !== 'msid') continue;
      var trackId = line.value.split(' ')[1];
      if (trackId === track.id) {
        var ssrc = line.id;
        ssrcs.add(ssrc);
        if (!firstSsrc) firstSsrc = ssrc;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (ssrcs.size === 0) throw new Error("a=ssrc line with msid information not found [track.id:".concat(track.id, "]"));
  var ssrcToRtxSsrc = new Map();
  // First assume RTX is used.
  var _iterator2 = _createForOfIteratorHelper(offerMediaObject.ssrcGroups || []),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _line = _step2.value;
      if (_line.semantics !== 'FID') continue;
      var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
        _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
        _ssrc = _line$ssrcs$split2[0],
        rtxSsrc = _line$ssrcs$split2[1];
      _ssrc = Number(_ssrc);
      rtxSsrc = Number(rtxSsrc);
      if (ssrcs.has(_ssrc)) {
        // Remove both the SSRC and RTX SSRC from the set so later we know that they
        // are already handled.
        ssrcs["delete"](_ssrc);
        ssrcs["delete"](rtxSsrc);
        // Add to the map.
        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
      }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var _iterator3 = _createForOfIteratorHelper(ssrcs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ssrc2 = _step3.value;
      // Add to the map.
      ssrcToRtxSsrc.set(_ssrc2, null);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var encodings = [];
  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        _ssrc3 = _step4$value[0],
        _rtxSsrc = _step4$value[1];
      var encoding = {
        ssrc: _ssrc3
      };
      if (_rtxSsrc) encoding.rtx = {
        ssrc: _rtxSsrc
      };
      encodings.push(encoding);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return encodings;
}
exports.getRtpEncodings = getRtpEncodings;
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast(_ref2) {
  var offerMediaObject = _ref2.offerMediaObject,
    track = _ref2.track,
    numStreams = _ref2.numStreams;
  if (numStreams <= 1) throw new TypeError('numStreams must be greater than 1');
  var firstSsrc;
  var firstRtxSsrc;
  var streamId;
  // Get the SSRC.
  var ssrcMsidLine = (offerMediaObject.ssrcs || []).find(function (line) {
    if (line.attribute !== 'msid') return false;
    var trackId = line.value.split(' ')[1];
    if (trackId === track.id) {
      firstSsrc = line.id;
      streamId = line.value.split(' ')[0];
      return true;
    } else {
      return false;
    }
  });
  if (!ssrcMsidLine) throw new Error("a=ssrc line with msid information not found [track.id:".concat(track.id, "]"));
  // Get the SSRC for RTX.
  (offerMediaObject.ssrcGroups || []).some(function (line) {
    if (line.semantics !== 'FID') return false;
    var ssrcs = line.ssrcs.split(/\s+/);
    if (Number(ssrcs[0]) === firstSsrc) {
      firstRtxSsrc = Number(ssrcs[1]);
      return true;
    } else {
      return false;
    }
  });
  var ssrcCnameLine = offerMediaObject.ssrcs.find(function (line) {
    return line.attribute === 'cname' && line.id === firstSsrc;
  });
  if (!ssrcCnameLine) throw new Error("a=ssrc line with cname information not found [track.id:".concat(track.id, "]"));
  var cname = ssrcCnameLine.value;
  var ssrcs = [];
  var rtxSsrcs = [];
  for (var i = 0; i < numStreams; ++i) {
    ssrcs.push(firstSsrc + i);
    if (firstRtxSsrc) rtxSsrcs.push(firstRtxSsrc + i);
  }
  offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
  offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
  offerMediaObject.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: ssrcs.join(' ')
  });
  for (var _i = 0; _i < ssrcs.length; ++_i) {
    var ssrc = ssrcs[_i];
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(track.id)
    });
  }
  for (var _i2 = 0; _i2 < rtxSsrcs.length; ++_i2) {
    var _ssrc4 = ssrcs[_i2];
    var rtxSsrc = rtxSsrcs[_i2];
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(track.id)
    });
    offerMediaObject.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(_ssrc4, " ").concat(rtxSsrc)
    });
  }
}
exports.addLegacySimulcast = addLegacySimulcast;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
function getRtpEncodings(_ref) {
  var offerMediaObject = _ref.offerMediaObject;
  var ssrcs = new Set();
  var _iterator = _createForOfIteratorHelper(offerMediaObject.ssrcs || []),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      var ssrc = line.id;
      ssrcs.add(ssrc);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (ssrcs.size === 0) throw new Error('no a=ssrc lines found');
  var ssrcToRtxSsrc = new Map();
  // First assume RTX is used.
  var _iterator2 = _createForOfIteratorHelper(offerMediaObject.ssrcGroups || []),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _line = _step2.value;
      if (_line.semantics !== 'FID') continue;
      var _line$ssrcs$split = _line.ssrcs.split(/\s+/),
        _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),
        _ssrc = _line$ssrcs$split2[0],
        rtxSsrc = _line$ssrcs$split2[1];
      _ssrc = Number(_ssrc);
      rtxSsrc = Number(rtxSsrc);
      if (ssrcs.has(_ssrc)) {
        // Remove both the SSRC and RTX SSRC from the set so later we know that they
        // are already handled.
        ssrcs["delete"](_ssrc);
        ssrcs["delete"](rtxSsrc);
        // Add to the map.
        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);
      }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var _iterator3 = _createForOfIteratorHelper(ssrcs),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ssrc2 = _step3.value;
      // Add to the map.
      ssrcToRtxSsrc.set(_ssrc2, null);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var encodings = [];
  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        _ssrc3 = _step4$value[0],
        _rtxSsrc = _step4$value[1];
      var encoding = {
        ssrc: _ssrc3
      };
      if (_rtxSsrc) encoding.rtx = {
        ssrc: _rtxSsrc
      };
      encodings.push(encoding);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return encodings;
}
exports.getRtpEncodings = getRtpEncodings;
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast(_ref2) {
  var offerMediaObject = _ref2.offerMediaObject,
    numStreams = _ref2.numStreams;
  if (numStreams <= 1) throw new TypeError('numStreams must be greater than 1');
  // Get the SSRC.
  var ssrcMsidLine = (offerMediaObject.ssrcs || []).find(function (line) {
    return line.attribute === 'msid';
  });
  if (!ssrcMsidLine) throw new Error('a=ssrc line with msid information not found');
  var _ssrcMsidLine$value$s = ssrcMsidLine.value.split(' '),
    _ssrcMsidLine$value$s2 = _slicedToArray(_ssrcMsidLine$value$s, 2),
    streamId = _ssrcMsidLine$value$s2[0],
    trackId = _ssrcMsidLine$value$s2[1];
  var firstSsrc = ssrcMsidLine.id;
  var firstRtxSsrc;
  // Get the SSRC for RTX.
  (offerMediaObject.ssrcGroups || []).some(function (line) {
    if (line.semantics !== 'FID') return false;
    var ssrcs = line.ssrcs.split(/\s+/);
    if (Number(ssrcs[0]) === firstSsrc) {
      firstRtxSsrc = Number(ssrcs[1]);
      return true;
    } else {
      return false;
    }
  });
  var ssrcCnameLine = offerMediaObject.ssrcs.find(function (line) {
    return line.attribute === 'cname';
  });
  if (!ssrcCnameLine) throw new Error('a=ssrc line with cname information not found');
  var cname = ssrcCnameLine.value;
  var ssrcs = [];
  var rtxSsrcs = [];
  for (var i = 0; i < numStreams; ++i) {
    ssrcs.push(firstSsrc + i);
    if (firstRtxSsrc) rtxSsrcs.push(firstRtxSsrc + i);
  }
  offerMediaObject.ssrcGroups = [];
  offerMediaObject.ssrcs = [];
  offerMediaObject.ssrcGroups.push({
    semantics: 'SIM',
    ssrcs: ssrcs.join(' ')
  });
  for (var _i = 0; _i < ssrcs.length; ++_i) {
    var ssrc = ssrcs[_i];
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: ssrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(trackId)
    });
  }
  for (var _i2 = 0; _i2 < rtxSsrcs.length; ++_i2) {
    var _ssrc4 = ssrcs[_i2];
    var rtxSsrc = rtxSsrcs[_i2];
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'cname',
      value: cname
    });
    offerMediaObject.ssrcs.push({
      id: rtxSsrc,
      attribute: 'msid',
      value: "".concat(streamId, " ").concat(trackId)
    });
    offerMediaObject.ssrcGroups.push({
      semantics: 'FID',
      ssrcs: "".concat(_ssrc4, " ").concat(rtxSsrc)
    });
  }
}
exports.addLegacySimulcast = addLegacySimulcast;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
exports.debug = debug_1["default"];
var Device_1 = __webpack_require__(/*! ./Device */ "./node_modules/mediasoup-client/lib/Device.js");
Object.defineProperty(exports, "Device", ({
  enumerable: true,
  get: function get() {
    return Device_1.Device;
  }
}));
Object.defineProperty(exports, "detectDevice", ({
  enumerable: true,
  get: function get() {
    return Device_1.detectDevice;
  }
}));
var types = __importStar(__webpack_require__(/*! ./types */ "./node_modules/mediasoup-client/lib/types.js"));
exports.types = types;
/**
 * Expose mediasoup-client version.
 */
exports.version = '3.6.69';
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ "./node_modules/mediasoup-client/lib/scalabilityModes.js");
Object.defineProperty(exports, "parseScalabilityMode", ({
  enumerable: true,
  get: function get() {
    return scalabilityModes_1.parse;
  }
}));

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/ortc.js":
/*!***************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/ortc.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;
var h264 = __importStar(__webpack_require__(/*! h264-profile-level-id */ "./node_modules/h264-profile-level-id/index.js"));
var utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/mediasoup-client/lib/utils.js"));
var RTP_PROBATOR_MID = 'probator';
var RTP_PROBATOR_SSRC = 1234;
var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCapabilities(caps) {
  if (_typeof(caps) !== 'object') throw new TypeError('caps is not an object');
  // codecs is optional. If unset, fill with an empty array.
  if (caps.codecs && !Array.isArray(caps.codecs)) throw new TypeError('caps.codecs is not an array');else if (!caps.codecs) caps.codecs = [];
  var _iterator = _createForOfIteratorHelper(caps.codecs),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var codec = _step.value;
      validateRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) throw new TypeError('caps.headerExtensions is not an array');else if (!caps.headerExtensions) caps.headerExtensions = [];
  var _iterator2 = _createForOfIteratorHelper(caps.headerExtensions),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var ext = _step2.value;
      validateRtpHeaderExtension(ext);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
exports.validateRtpCapabilities = validateRtpCapabilities;
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecCapability(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  if (_typeof(codec) !== 'object') throw new TypeError('codec is not an object');
  // mimeType is mandatory.
  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType');
  // Just override kind with media component of mimeType.
  codec.kind = mimeTypeMatch[1].toLowerCase();
  // preferredPayloadType is optional.
  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') throw new TypeError('invalid codec.preferredPayloadType');
  // clockRate is mandatory.
  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate');
  // channels is optional. If unset, set it to 1 (just if audio).
  if (codec.kind === 'audio') {
    if (typeof codec.channels !== 'number') codec.channels = 1;
  } else {
    delete codec.channels;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!codec.parameters || _typeof(codec.parameters) !== 'object') codec.parameters = {};
  for (var _i = 0, _Object$keys = Object.keys(codec.parameters); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var value = codec.parameters[key];
    if (value === undefined) {
      codec.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError("invalid codec parameter [key:".concat(key, "s, value:").concat(value, "]"));
    }
    // Specific parameters validation.
    if (key === 'apt') {
      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');
    }
  }
  // rtcpFeedback is optional. If unset, set it to an empty array.
  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];
  var _iterator3 = _createForOfIteratorHelper(codec.rtcpFeedback),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var fb = _step3.value;
      validateRtcpFeedback(fb);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}
exports.validateRtpCodecCapability = validateRtpCodecCapability;
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpFeedback(fb) {
  if (_typeof(fb) !== 'object') throw new TypeError('fb is not an object');
  // type is mandatory.
  if (!fb.type || typeof fb.type !== 'string') throw new TypeError('missing fb.type');
  // parameter is optional. If unset set it to an empty string.
  if (!fb.parameter || typeof fb.parameter !== 'string') fb.parameter = '';
}
exports.validateRtcpFeedback = validateRtcpFeedback;
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtension(ext) {
  if (_typeof(ext) !== 'object') throw new TypeError('ext is not an object');
  // kind is mandatory.
  if (ext.kind !== 'audio' && ext.kind !== 'video') throw new TypeError('invalid ext.kind');
  // uri is mandatory.
  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri');
  // preferredId is mandatory.
  if (typeof ext.preferredId !== 'number') throw new TypeError('missing ext.preferredId');
  // preferredEncrypt is optional. If unset set it to false.
  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') throw new TypeError('invalid ext.preferredEncrypt');else if (!ext.preferredEncrypt) ext.preferredEncrypt = false;
  // direction is optional. If unset set it to sendrecv.
  if (ext.direction && typeof ext.direction !== 'string') throw new TypeError('invalid ext.direction');else if (!ext.direction) ext.direction = 'sendrecv';
}
exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpParameters(params) {
  if (_typeof(params) !== 'object') throw new TypeError('params is not an object');
  // mid is optional.
  if (params.mid && typeof params.mid !== 'string') throw new TypeError('params.mid is not a string');
  // codecs is mandatory.
  if (!Array.isArray(params.codecs)) throw new TypeError('missing params.codecs');
  var _iterator4 = _createForOfIteratorHelper(params.codecs),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var codec = _step4.value;
      validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) throw new TypeError('params.headerExtensions is not an array');else if (!params.headerExtensions) params.headerExtensions = [];
  var _iterator5 = _createForOfIteratorHelper(params.headerExtensions),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var ext = _step5.value;
      validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (params.encodings && !Array.isArray(params.encodings)) throw new TypeError('params.encodings is not an array');else if (!params.encodings) params.encodings = [];
  var _iterator6 = _createForOfIteratorHelper(params.encodings),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var encoding = _step6.value;
      validateRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  if (params.rtcp && _typeof(params.rtcp) !== 'object') throw new TypeError('params.rtcp is not an object');else if (!params.rtcp) params.rtcp = {};
  validateRtcpParameters(params.rtcp);
}
exports.validateRtpParameters = validateRtpParameters;
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecParameters(codec) {
  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
  if (_typeof(codec) !== 'object') throw new TypeError('codec is not an object');
  // mimeType is mandatory.
  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');
  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType');
  // payloadType is mandatory.
  if (typeof codec.payloadType !== 'number') throw new TypeError('missing codec.payloadType');
  // clockRate is mandatory.
  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate');
  var kind = mimeTypeMatch[1].toLowerCase();
  // channels is optional. If unset, set it to 1 (just if audio).
  if (kind === 'audio') {
    if (typeof codec.channels !== 'number') codec.channels = 1;
  } else {
    delete codec.channels;
  }
  // parameters is optional. If unset, set it to an empty object.
  if (!codec.parameters || _typeof(codec.parameters) !== 'object') codec.parameters = {};
  for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    var value = codec.parameters[key];
    if (value === undefined) {
      codec.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new TypeError("invalid codec parameter [key:".concat(key, "s, value:").concat(value, "]"));
    }
    // Specific parameters validation.
    if (key === 'apt') {
      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');
    }
  }
  // rtcpFeedback is optional. If unset, set it to an empty array.
  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];
  var _iterator7 = _createForOfIteratorHelper(codec.rtcpFeedback),
    _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var fb = _step7.value;
      validateRtcpFeedback(fb);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
}
exports.validateRtpCodecParameters = validateRtpCodecParameters;
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
  if (_typeof(ext) !== 'object') throw new TypeError('ext is not an object');
  // uri is mandatory.
  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri');
  // id is mandatory.
  if (typeof ext.id !== 'number') throw new TypeError('missing ext.id');
  // encrypt is optional. If unset set it to false.
  if (ext.encrypt && typeof ext.encrypt !== 'boolean') throw new TypeError('invalid ext.encrypt');else if (!ext.encrypt) ext.encrypt = false;
  // parameters is optional. If unset, set it to an empty object.
  if (!ext.parameters || _typeof(ext.parameters) !== 'object') ext.parameters = {};
  for (var _i3 = 0, _Object$keys3 = Object.keys(ext.parameters); _i3 < _Object$keys3.length; _i3++) {
    var key = _Object$keys3[_i3];
    var value = ext.parameters[key];
    if (value === undefined) {
      ext.parameters[key] = '';
      value = '';
    }
    if (typeof value !== 'string' && typeof value !== 'number') throw new TypeError('invalid header extension parameter');
  }
}
exports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpEncodingParameters(encoding) {
  if (_typeof(encoding) !== 'object') throw new TypeError('encoding is not an object');
  // ssrc is optional.
  if (encoding.ssrc && typeof encoding.ssrc !== 'number') throw new TypeError('invalid encoding.ssrc');
  // rid is optional.
  if (encoding.rid && typeof encoding.rid !== 'string') throw new TypeError('invalid encoding.rid');
  // rtx is optional.
  if (encoding.rtx && _typeof(encoding.rtx) !== 'object') {
    throw new TypeError('invalid encoding.rtx');
  } else if (encoding.rtx) {
    // RTX ssrc is mandatory if rtx is present.
    if (typeof encoding.rtx.ssrc !== 'number') throw new TypeError('missing encoding.rtx.ssrc');
  }
  // dtx is optional. If unset set it to false.
  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') encoding.dtx = false;
  // scalabilityMode is optional.
  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') throw new TypeError('invalid encoding.scalabilityMode');
}
exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpParameters(rtcp) {
  if (_typeof(rtcp) !== 'object') throw new TypeError('rtcp is not an object');
  // cname is optional.
  if (rtcp.cname && typeof rtcp.cname !== 'string') throw new TypeError('invalid rtcp.cname');
  // reducedSize is optional. If unset set it to true.
  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') rtcp.reducedSize = true;
}
exports.validateRtcpParameters = validateRtcpParameters;
/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
  if (_typeof(caps) !== 'object') throw new TypeError('caps is not an object');
  // numStreams is mandatory.
  if (!caps.numStreams || _typeof(caps.numStreams) !== 'object') throw new TypeError('missing caps.numStreams');
  validateNumSctpStreams(caps.numStreams);
}
exports.validateSctpCapabilities = validateSctpCapabilities;
/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
  if (_typeof(numStreams) !== 'object') throw new TypeError('numStreams is not an object');
  // OS is mandatory.
  if (typeof numStreams.OS !== 'number') throw new TypeError('missing numStreams.OS');
  // MIS is mandatory.
  if (typeof numStreams.MIS !== 'number') throw new TypeError('missing numStreams.MIS');
}
exports.validateNumSctpStreams = validateNumSctpStreams;
/**
 * Validates SctpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpParameters(params) {
  if (_typeof(params) !== 'object') throw new TypeError('params is not an object');
  // port is mandatory.
  if (typeof params.port !== 'number') throw new TypeError('missing params.port');
  // OS is mandatory.
  if (typeof params.OS !== 'number') throw new TypeError('missing params.OS');
  // MIS is mandatory.
  if (typeof params.MIS !== 'number') throw new TypeError('missing params.MIS');
  // maxMessageSize is mandatory.
  if (typeof params.maxMessageSize !== 'number') throw new TypeError('missing params.maxMessageSize');
}
exports.validateSctpParameters = validateSctpParameters;
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpStreamParameters(params) {
  if (_typeof(params) !== 'object') throw new TypeError('params is not an object');
  // streamId is mandatory.
  if (typeof params.streamId !== 'number') throw new TypeError('missing params.streamId');
  // ordered is optional.
  var orderedGiven = false;
  if (typeof params.ordered === 'boolean') orderedGiven = true;else params.ordered = true;
  // maxPacketLifeTime is optional.
  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') throw new TypeError('invalid params.maxPacketLifeTime');
  // maxRetransmits is optional.
  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') throw new TypeError('invalid params.maxRetransmits');
  if (params.maxPacketLifeTime && params.maxRetransmits) throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
    params.ordered = false;
  }
  // label is optional.
  if (params.label && typeof params.label !== 'string') throw new TypeError('invalid params.label');
  // protocol is optional.
  if (params.protocol && typeof params.protocol !== 'string') throw new TypeError('invalid params.protocol');
}
exports.validateSctpStreamParameters = validateSctpStreamParameters;
/**
 * Generate extended RTP capabilities for sending and receiving.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps) {
  var extendedRtpCapabilities = {
    codecs: [],
    headerExtensions: []
  };
  // Match media codecs and keep the order preferred by remoteCaps.
  var _iterator8 = _createForOfIteratorHelper(remoteCaps.codecs || []),
    _step8;
  try {
    var _loop = function _loop() {
        var remoteCodec = _step8.value;
        if (isRtxCodec(remoteCodec)) return 0; // continue
        var matchingLocalCodec = (localCaps.codecs || []).find(function (localCodec) {
          return matchCodecs(localCodec, remoteCodec, {
            strict: true,
            modify: true
          });
        });
        if (!matchingLocalCodec) return 0; // continue
        var extendedCodec = {
          mimeType: matchingLocalCodec.mimeType,
          kind: matchingLocalCodec.kind,
          clockRate: matchingLocalCodec.clockRate,
          channels: matchingLocalCodec.channels,
          localPayloadType: matchingLocalCodec.preferredPayloadType,
          localRtxPayloadType: undefined,
          remotePayloadType: remoteCodec.preferredPayloadType,
          remoteRtxPayloadType: undefined,
          localParameters: matchingLocalCodec.parameters,
          remoteParameters: remoteCodec.parameters,
          rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
      },
      _ret;
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
    // Match RTX codecs.
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  var _iterator9 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step9;
  try {
    var _loop2 = function _loop2() {
      var extendedCodec = _step9.value;
      var matchingLocalRtxCodec = localCaps.codecs.find(function (localCodec) {
        return isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType;
      });
      var matchingRemoteRtxCodec = remoteCaps.codecs.find(function (remoteCodec) {
        return isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType;
      });
      if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
        extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
        extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
      }
    };
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      _loop2();
    }
    // Match header extensions.
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  var _iterator10 = _createForOfIteratorHelper(remoteCaps.headerExtensions),
    _step10;
  try {
    var _loop3 = function _loop3() {
      var remoteExt = _step10.value;
      var matchingLocalExt = localCaps.headerExtensions.find(function (localExt) {
        return matchHeaderExtensions(localExt, remoteExt);
      });
      if (!matchingLocalExt) return 1; // continue
      var extendedExt = {
        kind: remoteExt.kind,
        uri: remoteExt.uri,
        sendId: matchingLocalExt.preferredId,
        recvId: remoteExt.preferredId,
        encrypt: matchingLocalExt.preferredEncrypt,
        direction: 'sendrecv'
      };
      switch (remoteExt.direction) {
        case 'sendrecv':
          extendedExt.direction = 'sendrecv';
          break;
        case 'recvonly':
          extendedExt.direction = 'sendonly';
          break;
        case 'sendonly':
          extendedExt.direction = 'recvonly';
          break;
        case 'inactive':
          extendedExt.direction = 'inactive';
          break;
      }
      extendedRtpCapabilities.headerExtensions.push(extendedExt);
    };
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      if (_loop3()) continue;
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
  return extendedRtpCapabilities;
}
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
  var rtpCapabilities = {
    codecs: [],
    headerExtensions: []
  };
  var _iterator11 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step11;
  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var extendedCodec = _step11.value;
      var codec = {
        mimeType: extendedCodec.mimeType,
        kind: extendedCodec.kind,
        preferredPayloadType: extendedCodec.remotePayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpCapabilities.codecs.push(codec);
      // Add RTX codec.
      if (!extendedCodec.remoteRtxPayloadType) continue;
      var rtxCodec = {
        mimeType: "".concat(extendedCodec.kind, "/rtx"),
        kind: extendedCodec.kind,
        preferredPayloadType: extendedCodec.remoteRtxPayloadType,
        clockRate: extendedCodec.clockRate,
        parameters: {
          apt: extendedCodec.remotePayloadType
        },
        rtcpFeedback: []
      };
      rtpCapabilities.codecs.push(rtxCodec);
      // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }
  var _iterator12 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step12;
  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var extendedExtension = _step12.value;
      // Ignore RTP extensions not valid for receiving.
      if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {
        continue;
      }
      var ext = {
        kind: extendedExtension.kind,
        uri: extendedExtension.uri,
        preferredId: extendedExtension.recvId,
        preferredEncrypt: extendedExtension.encrypt,
        direction: extendedExtension.direction
      };
      rtpCapabilities.headerExtensions.push(ext);
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }
  return rtpCapabilities;
}
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
  var rtpParameters = {
    mid: undefined,
    codecs: [],
    headerExtensions: [],
    encodings: [],
    rtcp: {}
  };
  var _iterator13 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step13;
  try {
    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
      var extendedCodec = _step13.value;
      if (extendedCodec.kind !== kind) continue;
      var codec = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(codec);
      // Add RTX codec.
      if (extendedCodec.localRtxPayloadType) {
        var rtxCodec = {
          mimeType: "".concat(extendedCodec.kind, "/rtx"),
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
  } catch (err) {
    _iterator13.e(err);
  } finally {
    _iterator13.f();
  }
  var _iterator14 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step14;
  try {
    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
      var extendedExtension = _step14.value;
      // Ignore RTP extensions of a different kind and those not valid for sending.
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {
        continue;
      }
      var ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
  } catch (err) {
    _iterator14.e(err);
  } finally {
    _iterator14.f();
  }
  return rtpParameters;
}
exports.getSendingRtpParameters = getSendingRtpParameters;
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
  var rtpParameters = {
    mid: undefined,
    codecs: [],
    headerExtensions: [],
    encodings: [],
    rtcp: {}
  };
  var _iterator15 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),
    _step15;
  try {
    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
      var extendedCodec = _step15.value;
      if (extendedCodec.kind !== kind) continue;
      var _codec3 = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.remoteParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(_codec3);
      // Add RTX codec.
      if (extendedCodec.localRtxPayloadType) {
        var rtxCodec = {
          mimeType: "".concat(extendedCodec.kind, "/rtx"),
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
  } catch (err) {
    _iterator15.e(err);
  } finally {
    _iterator15.f();
  }
  var _iterator16 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),
    _step16;
  try {
    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
      var extendedExtension = _step16.value;
      // Ignore RTP extensions of a different kind and those not valid for sending.
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {
        continue;
      }
      var ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
  } catch (err) {
    _iterator16.e(err);
  } finally {
    _iterator16.f();
  }
  if (rtpParameters.headerExtensions.some(function (ext) {
    return ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';
  })) {
    var _iterator17 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step17;
    try {
      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
        var codec = _step17.value;
        codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(function (fb) {
          return fb.type !== 'goog-remb';
        });
      }
    } catch (err) {
      _iterator17.e(err);
    } finally {
      _iterator17.f();
    }
  } else if (rtpParameters.headerExtensions.some(function (ext) {
    return ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';
  })) {
    var _iterator18 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step18;
    try {
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        var _codec = _step18.value;
        _codec.rtcpFeedback = (_codec.rtcpFeedback || []).filter(function (fb) {
          return fb.type !== 'transport-cc';
        });
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
  } else {
    var _iterator19 = _createForOfIteratorHelper(rtpParameters.codecs),
      _step19;
    try {
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        var _codec2 = _step19.value;
        _codec2.rtcpFeedback = (_codec2.rtcpFeedback || []).filter(function (fb) {
          return fb.type !== 'transport-cc' && fb.type !== 'goog-remb';
        });
      }
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }
  }
  return rtpParameters;
}
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
  var filteredCodecs = [];
  // If no capability codec is given, take the first one (and RTX).
  if (!capCodec) {
    filteredCodecs.push(codecs[0]);
    if (isRtxCodec(codecs[1])) filteredCodecs.push(codecs[1]);
  }
  // Otherwise look for a compatible set of codecs.
  else {
    for (var idx = 0; idx < codecs.length; ++idx) {
      if (matchCodecs(codecs[idx], capCodec)) {
        filteredCodecs.push(codecs[idx]);
        if (isRtxCodec(codecs[idx + 1])) filteredCodecs.push(codecs[idx + 1]);
        break;
      }
    }
    if (filteredCodecs.length === 0) throw new TypeError('no matching codec found');
  }
  return filteredCodecs;
}
exports.reduceCodecs = reduceCodecs;
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
  // Clone given reference video RTP parameters.
  videoRtpParameters = utils.clone(videoRtpParameters, {});
  // This may throw.
  validateRtpParameters(videoRtpParameters);
  var rtpParameters = {
    mid: RTP_PROBATOR_MID,
    codecs: [],
    headerExtensions: [],
    encodings: [{
      ssrc: RTP_PROBATOR_SSRC
    }],
    rtcp: {
      cname: 'probator'
    }
  };
  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
  return rtpParameters;
}
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, extendedRtpCapabilities) {
  return extendedRtpCapabilities.codecs.some(function (codec) {
    return codec.kind === kind;
  });
}
exports.canSend = canSend;
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, extendedRtpCapabilities) {
  // This may throw.
  validateRtpParameters(rtpParameters);
  if (rtpParameters.codecs.length === 0) return false;
  var firstMediaCodec = rtpParameters.codecs[0];
  return extendedRtpCapabilities.codecs.some(function (codec) {
    return codec.remotePayloadType === firstMediaCodec.payloadType;
  });
}
exports.canReceive = canReceive;
function isRtxCodec(codec) {
  if (!codec) return false;
  return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$strict = _ref.strict,
    strict = _ref$strict === void 0 ? false : _ref$strict,
    _ref$modify = _ref.modify,
    modify = _ref$modify === void 0 ? false : _ref$modify;
  var aMimeType = aCodec.mimeType.toLowerCase();
  var bMimeType = bCodec.mimeType.toLowerCase();
  if (aMimeType !== bMimeType) return false;
  if (aCodec.clockRate !== bCodec.clockRate) return false;
  if (aCodec.channels !== bCodec.channels) return false;
  // Per codec special checks.
  switch (aMimeType) {
    case 'video/h264':
      {
        if (strict) {
          var aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;
          var bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;
          if (aPacketizationMode !== bPacketizationMode) return false;
          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) return false;
          var selectedProfileLevelId;
          try {
            selectedProfileLevelId = h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);
          } catch (error) {
            return false;
          }
          if (modify) {
            if (selectedProfileLevelId) {
              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
            } else {
              delete aCodec.parameters['profile-level-id'];
              delete bCodec.parameters['profile-level-id'];
            }
          }
        }
        break;
      }
    case 'video/vp9':
      {
        if (strict) {
          var aProfileId = aCodec.parameters['profile-id'] || 0;
          var bProfileId = bCodec.parameters['profile-id'] || 0;
          if (aProfileId !== bProfileId) return false;
        }
        break;
      }
  }
  return true;
}
function matchHeaderExtensions(aExt, bExt) {
  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;
  if (aExt.uri !== bExt.uri) return false;
  return true;
}
function reduceRtcpFeedback(codecA, codecB) {
  var reducedRtcpFeedback = [];
  var _iterator20 = _createForOfIteratorHelper(codecA.rtcpFeedback || []),
    _step20;
  try {
    var _loop4 = function _loop4() {
      var aFb = _step20.value;
      var matchingBFb = (codecB.rtcpFeedback || []).find(function (bFb) {
        return bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter);
      });
      if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);
    };
    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
      _loop4();
    }
  } catch (err) {
    _iterator20.e(err);
  } finally {
    _iterator20.f();
  }
  return reducedRtcpFeedback;
}

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/scalabilityModes.js":
/*!***************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/scalabilityModes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parse = void 0;
var ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
  var match = ScalabilityModeRegex.exec(scalabilityMode || '');
  if (match) {
    return {
      spatialLayers: Number(match[1]),
      temporalLayers: Number(match[2])
    };
  } else {
    return {
      spatialLayers: 1,
      temporalLayers: 1
    };
  }
}
exports.parse = parse;

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/types.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/types.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
__exportStar(__webpack_require__(/*! ./Device */ "./node_modules/mediasoup-client/lib/Device.js"), exports);
__exportStar(__webpack_require__(/*! ./Transport */ "./node_modules/mediasoup-client/lib/Transport.js"), exports);
__exportStar(__webpack_require__(/*! ./Producer */ "./node_modules/mediasoup-client/lib/Producer.js"), exports);
__exportStar(__webpack_require__(/*! ./Consumer */ "./node_modules/mediasoup-client/lib/Consumer.js"), exports);
__exportStar(__webpack_require__(/*! ./DataProducer */ "./node_modules/mediasoup-client/lib/DataProducer.js"), exports);
__exportStar(__webpack_require__(/*! ./DataConsumer */ "./node_modules/mediasoup-client/lib/DataConsumer.js"), exports);
__exportStar(__webpack_require__(/*! ./RtpParameters */ "./node_modules/mediasoup-client/lib/RtpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./SctpParameters */ "./node_modules/mediasoup-client/lib/SctpParameters.js"), exports);
__exportStar(__webpack_require__(/*! ./handlers/HandlerInterface */ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/mediasoup-client/lib/errors.js"), exports);

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generateRandomNumber = exports.clone = void 0;
/**
 * Clones the given data.
 */
function clone(data, defaultValue) {
  if (typeof data === 'undefined') return defaultValue;
  return JSON.parse(JSON.stringify(data));
}
exports.clone = clone;
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
  return Math.round(Math.random() * 10000000);
}
exports.generateRandomNumber = generateRandomNumber;

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = _typeof(val);
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/***/ ((module) => {

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: 'name'
  }],
  i: [{
    name: 'description'
  }],
  u: [{
    name: 'uri'
  }],
  e: [{
    name: 'email'
  }],
  p: [{
    name: 'phone'
  }],
  z: [{
    name: 'timezones'
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: 'repeats'
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [{
    // a=rtpmap:110 opus/48000/2
    push: 'rtp',
    reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
    names: ['payload', 'codec', 'rate', 'encoding'],
    format: function format(o) {
      return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';
    }
  }, {
    // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
    // a=fmtp:111 minptime=10; useinbandfec=1
    push: 'fmtp',
    reg: /^fmtp:(\d*) ([\S| ]*)/,
    names: ['payload', 'config'],
    format: 'fmtp:%d %s'
  }, {
    // a=control:streamid=0
    name: 'control',
    reg: /^control:(.*)/,
    format: 'control:%s'
  }, {
    // a=rtcp:65179 IN IP4 193.84.77.194
    name: 'rtcp',
    reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
    names: ['port', 'netType', 'ipVer', 'address'],
    format: function format(o) {
      return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';
    }
  }, {
    // a=rtcp-fb:98 trr-int 100
    push: 'rtcpFbTrrInt',
    reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
    names: ['payload', 'value'],
    format: 'rtcp-fb:%s trr-int %d'
  }, {
    // a=rtcp-fb:98 nack rpsi
    push: 'rtcpFb',
    reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
    names: ['payload', 'type', 'subtype'],
    format: function format(o) {
      return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';
    }
  }, {
    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
    // a=extmap:1/recvonly URI-gps-string
    // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
    push: 'ext',
    reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
    names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
    format: function format(o) {
      return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');
    }
  }, {
    // a=extmap-allow-mixed
    name: 'extmapAllowMixed',
    reg: /^(extmap-allow-mixed)/
  }, {
    // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
    push: 'crypto',
    reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
    names: ['id', 'suite', 'config', 'sessionConfig'],
    format: function format(o) {
      return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';
    }
  }, {
    // a=setup:actpass
    name: 'setup',
    reg: /^setup:(\w*)/,
    format: 'setup:%s'
  }, {
    // a=connection:new
    name: 'connectionType',
    reg: /^connection:(new|existing)/,
    format: 'connection:%s'
  }, {
    // a=mid:1
    name: 'mid',
    reg: /^mid:([^\s]*)/,
    format: 'mid:%s'
  }, {
    // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
    name: 'msid',
    reg: /^msid:(.*)/,
    format: 'msid:%s'
  }, {
    // a=ptime:20
    name: 'ptime',
    reg: /^ptime:(\d*(?:\.\d*)*)/,
    format: 'ptime:%d'
  }, {
    // a=maxptime:60
    name: 'maxptime',
    reg: /^maxptime:(\d*(?:\.\d*)*)/,
    format: 'maxptime:%d'
  }, {
    // a=sendrecv
    name: 'direction',
    reg: /^(sendrecv|recvonly|sendonly|inactive)/
  }, {
    // a=ice-lite
    name: 'icelite',
    reg: /^(ice-lite)/
  }, {
    // a=ice-ufrag:F7gI
    name: 'iceUfrag',
    reg: /^ice-ufrag:(\S*)/,
    format: 'ice-ufrag:%s'
  }, {
    // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
    name: 'icePwd',
    reg: /^ice-pwd:(\S*)/,
    format: 'ice-pwd:%s'
  }, {
    // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
    name: 'fingerprint',
    reg: /^fingerprint:(\S*) (\S*)/,
    names: ['type', 'hash'],
    format: 'fingerprint:%s %s'
  }, {
    // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
    // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
    // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
    // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
    // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
    push: 'candidates',
    reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
    names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
    format: function format(o) {
      var str = 'candidate:%s %d %s %d %s %d typ %s';
      str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';

      // NB: candidate has three optional chunks, so %void middles one if it's missing
      str += o.tcptype != null ? ' tcptype %s' : '%v';
      if (o.generation != null) {
        str += ' generation %d';
      }
      str += o['network-id'] != null ? ' network-id %d' : '%v';
      str += o['network-cost'] != null ? ' network-cost %d' : '%v';
      return str;
    }
  }, {
    // a=end-of-candidates (keep after the candidates line for readability)
    name: 'endOfCandidates',
    reg: /^(end-of-candidates)/
  }, {
    // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
    name: 'remoteCandidates',
    reg: /^remote-candidates:(.*)/,
    format: 'remote-candidates:%s'
  }, {
    // a=ice-options:google-ice
    name: 'iceOptions',
    reg: /^ice-options:(\S*)/,
    format: 'ice-options:%s'
  }, {
    // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
    push: 'ssrcs',
    reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
    names: ['id', 'attribute', 'value'],
    format: function format(o) {
      var str = 'ssrc:%d';
      if (o.attribute != null) {
        str += ' %s';
        if (o.value != null) {
          str += ':%s';
        }
      }
      return str;
    }
  }, {
    // a=ssrc-group:FEC 1 2
    // a=ssrc-group:FEC-FR 3004364195 1080772241
    push: 'ssrcGroups',
    // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
    reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
    names: ['semantics', 'ssrcs'],
    format: 'ssrc-group:%s %s'
  }, {
    // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
    name: 'msidSemantic',
    reg: /^msid-semantic:\s?(\w*) (\S*)/,
    names: ['semantic', 'token'],
    format: 'msid-semantic: %s %s' // space after ':' is not accidental
  }, {
    // a=group:BUNDLE audio video
    push: 'groups',
    reg: /^group:(\w*) (.*)/,
    names: ['type', 'mids'],
    format: 'group:%s %s'
  }, {
    // a=rtcp-mux
    name: 'rtcpMux',
    reg: /^(rtcp-mux)/
  }, {
    // a=rtcp-rsize
    name: 'rtcpRsize',
    reg: /^(rtcp-rsize)/
  }, {
    // a=sctpmap:5000 webrtc-datachannel 1024
    name: 'sctpmap',
    reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
    names: ['sctpmapNumber', 'app', 'maxMessageSize'],
    format: function format(o) {
      return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';
    }
  }, {
    // a=x-google-flag:conference
    name: 'xGoogleFlag',
    reg: /^x-google-flag:([^\s]*)/,
    format: 'x-google-flag:%s'
  }, {
    // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
    push: 'rids',
    reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
    names: ['id', 'direction', 'params'],
    format: function format(o) {
      return o.params ? 'rid:%s %s %s' : 'rid:%s %s';
    }
  }, {
    // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
    // a=imageattr:* send [x=800,y=640] recv *
    // a=imageattr:100 recv [x=320,y=240]
    push: 'imageattrs',
    reg: new RegExp(
    // a=imageattr:97
    '^imageattr:(\\d+|\\*)' +
    // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
    '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
    // recv [x=330,y=250]
    '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'),
    names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
    format: function format(o) {
      return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
    }
  }, {
    // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
    // a=simulcast:recv 1;4,5 send 6;7
    name: 'simulcast',
    reg: new RegExp(
    // a=simulcast:
    '^simulcast:' +
    // send 1,2,3;~4,~5
    '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
    // space + recv 6;~7,~8
    '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
    // end
    '$'),
    names: ['dir1', 'list1', 'dir2', 'list2'],
    format: function format(o) {
      return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
    }
  }, {
    // old simulcast draft 03 (implemented by Firefox)
    //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
    // a=simulcast: recv pt=97;98 send pt=97
    // a=simulcast: send rid=5;6;7 paused=6,7
    name: 'simulcast_03',
    reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
    names: ['value'],
    format: 'simulcast: %s'
  }, {
    // a=framerate:25
    // a=framerate:29.97
    name: 'framerate',
    reg: /^framerate:(\d+(?:$|\.\d+))/,
    format: 'framerate:%s'
  }, {
    // RFC4570
    // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
    name: 'sourceFilter',
    reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
    names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
    format: 'source-filter: %s %s %s %s %s'
  }, {
    // a=bundle-only
    name: 'bundleOnly',
    reg: /^(bundle-only)/
  }, {
    // a=label:1
    name: 'label',
    reg: /^label:(.+)/,
    format: 'label:%s'
  }, {
    // RFC version 26 for SCTP over DTLS
    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
    name: 'sctpPort',
    reg: /^sctp-port:(\d+)$/,
    format: 'sctp-port:%s'
  }, {
    // RFC version 26 for SCTP over DTLS
    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
    name: 'maxMessageSize',
    reg: /^max-message-size:(\d+)$/,
    format: 'max-message-size:%s'
  }, {
    // RFC7273
    // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
    push: 'tsRefClocks',
    reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
    names: ['clksrc', 'clksrcExt'],
    format: function format(o) {
      return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
    }
  }, {
    // RFC7273
    // a=mediaclk:direct=963214424
    name: 'mediaClk',
    reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
    names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
    format: function format(o) {
      var str = 'mediaclk:';
      str += o.id != null ? 'id=%s %s' : '%v%s';
      str += o.mediaClockValue != null ? '=%s' : '';
      str += o.rateNumerator != null ? ' rate=%s' : '';
      str += o.rateDenominator != null ? '/%s' : '';
      return str;
    }
  }, {
    // a=keywds:keywords
    name: 'keywords',
    reg: /^keywds:(.+)$/,
    format: 'keywds:%s'
  }, {
    // a=content:main
    name: 'content',
    reg: /^content:(.+)/,
    format: 'content:%s'
  },
  // BFCP https://tools.ietf.org/html/rfc4583
  {
    // a=floorctrl:c-s
    name: 'bfcpFloorCtrl',
    reg: /^floorctrl:(c-only|s-only|c-s)/,
    format: 'floorctrl:%s'
  }, {
    // a=confid:1
    name: 'bfcpConfId',
    reg: /^confid:(\d+)/,
    format: 'confid:%s'
  }, {
    // a=userid:1
    name: 'bfcpUserId',
    reg: /^userid:(\d+)/,
    format: 'userid:%s'
  }, {
    // a=floorid:1
    name: 'bfcpFloorId',
    reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
    names: ['id', 'mStream'],
    format: 'floorid:%s mstrm:%s'
  }, {
    // any a= that we don't understand is kept verbatim on media.invalid
    push: 'invalid',
    names: ['value']
  }]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var parser = __webpack_require__(/*! ./parser */ "./node_modules/sdp-transform/lib/parser.js");
var writer = __webpack_require__(/*! ./writer */ "./node_modules/sdp-transform/lib/writer.js");
exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var toIntIfInt = function toIntIfInt(v) {
  return String(Number(v)) === v ? Number(v) : v;
};
var attachProperties = function attachProperties(match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  } else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i + 1] != null) {
        location[names[i]] = toIntIfInt(match[i + 1]);
      }
    }
  }
};
var parseReg = function parseReg(obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  } else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ? {} :
  // blank object that will be pushed
  needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};
var grammar = __webpack_require__(/*! ./grammar */ "./node_modules/sdp-transform/lib/grammar.js");
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
exports.parse = function (sdp) {
  var session = {},
    media = [],
    location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({
        rtp: [],
        fmtp: []
      });
      location = media[media.length - 1]; // point at latest media line
    }
    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });
  session.media = media; // link it up
  return session;
};
var paramReducer = function paramReducer(acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};
exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;
exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};
exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};
exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});
  });
};
exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid,
        paused = false;
      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }
      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var grammar = __webpack_require__(/*! ./grammar */ "./node_modules/sdp-transform/lib/grammar.js");

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function format(formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};
var makeLine = function makeLine(type, obj, location) {
  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      } else {
        // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  } else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];
module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });
  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      } else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));
    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        } else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });
  return sdp.join('\r\n') + '\r\n';
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./src-ts/index.ts ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mediasoup-client */ "./node_modules/mediasoup-client/lib/index.js");
/* harmony import */ var mediasoup_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mediasoup_client__WEBPACK_IMPORTED_MODULE_0__);

const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("sdk-client");


;
// import debug from 'debug';
// export default typescript;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mediasoup_client__WEBPACK_IMPORTED_MODULE_0__);

})();

window.sdkClient = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=sdk.client.window.js.map